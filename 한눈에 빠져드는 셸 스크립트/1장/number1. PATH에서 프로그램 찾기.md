환경 변수를 사용하는(MAILER나 PAGER와 같은) 셸 스크립트는 숨겨진 위험을 갖고 있다. 예를 들어, 설정 중 일부는 존재하지 않는 프로그램을 가리킬 수 있다. 이러한 환경 변수 문제와 마주치기 전에, MAILER를 선호하는 전자 메일 프로그램(/usr/bin/mailx와 같은)으로 설정하고, PAGER는 긴 문서를 한 번에 한 화면(page)로 보기 위해 사용하는 프로그램으로 설정해야 한다. 예를 들어, PAGER 설정을 사용해 시스템의 기본 페이징 프로그램(일반적인 경우 more나 [[less]] 프로그램일 수 있음)을 사용하는 대신, 스크립트 출력을 유연하게 표시하도록 어떻게 PAGER 환경 변수가 유효한 프로그램에 세팅돼 있는지 확신하는가?

이 첫 번째 스크립트는 주어진 프로그램이 사용자의 PATH에서 발견될 수 있는지 여부를 테스트하는 방법을 설명한다. 또한 스크립트 함수와 변수 슬라이싱(variable slicing)등 여러 가지 셸 스크립팅 기술(shell-scripting techniques)을 잘 보여준다. [리스트 1-1]은 경로가 유효한지 확인하는 방법을 보여준다.


### 코드

- [리스트 1-1]: inpath 셸 스크립트 함수

```shell
#!/bin/bash

# inpath-- 특정 프로그램이 유용한지

# 또는 모든 PATH 디렉터리 목록에서 찾을 수 있는지 확인한다.

  

in_path(){

# 주어진 명령어와 PATH로 명령어를 찾는다. 발견돼 실행 가능하면 0을 리턴하고

# 만약 그렇지 않다면 1을 리턴한다. 이것은 일시적으로 IFS(내부 필드 분리 기호)를 수정하지만,

# 완료 후 복원한다.

  

cmd=$1 ourpath=$2 result=1

oldIFS=$IFS IFS=":"

  

for directory in $ourpath

do

if [ -x $directory/$cmd ] ; then

result=0

fi

done

  

IFS=$oldIFS

return $result

}

  

checkForCmdInPath(){

var=$1

if [ "$var" != "" ]; then

if [ "${var:0:1}" = "/" ]; then # (1)

	if [ ! -x $var ]; then    # (2)

return 1

fi

elif ! in_path $var "$PATH" ; then #(3)

return 2

fi

fi

}
```

0장에서 언급한 것처럼 home 디렉터리에 scripts라는 새 디렉터리를 생성한 후, PATH 변수에 완전한 디렉터리 이름을 추가하는 것이 좋다. `echo $PATH` 명령어를 사용해 현재 PATH를 확인하고 로그인 스크립트(`.login`, `.profile`, `.bashrc`, `.bash_profile`)의 내용을 편집해 PATH를 적절히 수정한다. 좀 더 자세한 내용은 47쪽의 "로그인 스크립트 구성하기"를 참조하라.

>[!Note] 노트
>[[ls]] 명령을 사용해 터미널에서 파일을 나열하는 경우, `.bashrc`
나 `.bash_pro` 파일과 같은 일부 특수 파일이 맨 위에 표시되지 않을 수 있다. 이것은 `.bashrc`처럼 마침표로 시작하는 파일은 파일 시스템에 의해 "숨겨진 것"으로 간주되기 때문이다(이것은 유닉스에서 매우 초기에 버그에서 발전된 기능(bug-turned-feature)으로 밝혀졌다). 숨겨진 것을 포함해 디렉터리의 모든 파일을 볼려면, ls에 `-a` 옵션을 사용하면 된다.

다시 한 번 강조하지만, '모든 스크립트를 bash로 실행한다'라고 가정한다. 이 스크립트는 `/bin/bash`를 호출하기 위해 첫 번째 행(shebang이라고 함)을 명시적으로 설정한다. 많은 시스템은 런타임으로 shebang 세팅, `/usr/bin/env bash`를 지원한다.

>[!Note] 주석에 대한 노트
>우리는 각 스크립트의 동작 방식에 대한 자세한 설명을 포함할지 여부에 대해 고민했다. 어떤 경우에는 코드 다음에 까다로운 코딩 세그먼트에 대한 설명을 제공하겠지만, 일반적으로 코드 주석을 사용해 상황에 따라 설명한다. `#` 기호로 시작하는 줄을 찾거나 때로는 코드 줄의 `#`뒤에 나타나는 줄을 찾으면 된다.
>의심할 여지없이 다른 사람의 스크립트(물론 우리 이외의 스크립트)를 읽는다면, 주석을 읽음으로써 스크립트를 통해 도대체 무슨 일이 일어나고 있는지 알아내는 연습을 하는 것이 유용하다. 또한 특정 코드 블록에서 목적을 달성하였고, 무엇을 찾고 있는지 알려주기 위해 스크립트를 작성할 때 주석을 넣는 것은 휼륭한 습관이다.


### 동작 방식

checkForCmdInPath를 실행하기 위한 열쇠는 프로그램 이름(echo와 같은)을 포함하는 변수와 전체 디렉터리 경로가 포함된 파일 이름(/bin/echo와 같은)을 갖고 있는 변수를 구별할 수 있도록 하는 것이다. 주어진 값의 첫 번째 문자를 검사해 문자가 슬래시(/)인지 여부를 확인해야 하므로 변숫값에서 첫 번째 문자를 분리해야 한다.

(1)에서 변수 슬라이싱(variable-slicing syntax)인 `${var:0:1}`은 오프셋에서 시작해 지정된 길이까지 문자열을 substring해주는 단축 표기법(shorthand notation)이다. 길이가 지정돼 있지 않은 경우는 나머지 전체 문자열을 리턴한다. 예를 들어, `${var:0:1}` 표현식은 10번재 문자부터 `$var`의 나머지 값을 리턴하여, `${var:10:5}`는 위치 10에서 15번째 사이(10rhk 15번째도 포함)의 문자들로 substring한다. 다음 예제에서 무엇을 의미하는지 알 수 있을 것이다.

```shell
┌──(kali㉿kali)-[~]
└─$ var="something wicked this way comes..."
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo ${var:10}
wicked this way comes...
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo ${var:10:6} 
wicked

```

[리스트 1-1]에서 구문은 지정된 경로에 슬래시가 선행에 있는지 확인하는데 사용된다. 일단 스크립트에 전달된 경로가 슬래시로 시작하는지의 여부를 결정한 후, 실제로 파일 시스템에서 경로를 찾을 수 있는지 확인한다. 주어진 경로가 절대 경로라 가정하고 `-x` bash 연산자(2)를 사용해 경로가 존재하는지 확인한다. 그렇지 않으면, inpath 함수(3)에 값을 전달해 기본값 PATH에 설정된 디렉터리에 값을 찾을 수 있는지를 확인한다.


---
### 스크립트 실행하기

이 스크립트를 자립형 스크립트(a stand-alone program)으로 실행하려면, 먼저 파일의 끝에 짧은 명령어 블록을 추가해야 한다. 이 명령은 실제로 사용자 입력을 받고 다음에서 보여주는 것처럼 우리가 작성한 함수로 기본 작업을 수행한다.

```shell
if [ $# -ne 1 ]; then

echo "Usage: $0 command" >&2

exit 1

fi

  

checkForCmdInPath "$1"

  

case "$1" in

0)

echo "$1 found in PATH"

;;

1)

echo "$1 not found or not executable"

;;

2)

echo "$1 not found in PATH"

;;

esac

  

exit 0
```

코드를 추가하고 나면, "결과" 다음에 표시된 대로 스크립트를 직접 호출할 수 있다. 그러나 스크립트를 모두 끝냈을 때 이 추가 코드를 제거하거나 주석 처리를 하기 바란다. 이는 나중에 혼란 없이 라이브러리 함수로 포함시키기 위해서다.

---

### 결과

스크립트를 테스트하기 위해, 3개의 프로그램 이름(존재하는 프로그램, 존재하지만 PATH에는 없는 프로그램, 존재하진 않지만 완전한 이름과 패스를 가진 프로그램)으로 input를 호출해 보자. [리스트 1-2]는 스크립트의 테스트의 예를 보여준다.

- [리스트 1-2]: inpath 스크립트 테스트
```shell
┌──(kali㉿kali)-[~/Documents/bin]
└─$ inpath echo  
echo found in PATH
                                                                                                                   
┌──(kali㉿kali)-[~/Documents/bin]
└─$ inpath MrEcho
MrEcho not found in PATH
                                                                                                                   
┌──(kali㉿kali)-[~/Documents/bin]
└─$ inpath /usr/bin/MrEcho
/usr/bin/MrEcho not found or not executable

```


---

### 스크립트 해킹하기


첫 번째 스크립트에서 코드 닌자(a code ninja)가 되고 싶다면, `${var:0:1}` 표현을 좀 더 복잡한 표현인 `${var%${var#?}}`으로 바꾸자. 이것은 POSIX 가변 슬라이싱 메서드(variable-slicing method)다. 2개의 중첩된 문자열 조각이어서 알아보기 힘든 표현(gobbledygook)이다. `${var#?}`의 내부 호출은 var의 첫 번째 문자를 제외한 모든 문자를 추출한다. 여기서 `#`은 주어진 패턴의 첫 번째 인스턴스를 삭제하기 위한 호출이고, `?`은 정확히 하나의 문자를 매치하는 정규식이다.
다음으로, `${var%pattern}` 호출은 var에서 지정된 패턴이 제거되면 남긴 모든 것을 문자열로 생성한다. 이 경우, 제거되는 패턴은 내부 호출 결과이므로 남는 것은 문자열의 첫 번째 문자가 된다.
이 POSIX 표기법(notation)이 너무 파격적이면, bash, ksh 및 zsh 포함하는 대부분의 셸은 스크립트에서 사용됐던 다른 변수 슬라이싱 메서드, `${varname:start:size}`를 지원한다.

물론 첫 번째 문자를 추출하는 이러한 기술이 마음에 들지 않으면, `$(echo $var | cut -cl)`과 같은 시스템 호출(call)을 사용할 수도 있다. bash 프로그래밍을 사용하면 시스템에서 데이터를 추출, 변환 또는 로드하는 등 여러 가지 방법으로 문제를 해결할 수 있다. 이러한 "목표를 달성하기 위한 여러 가지 방법(many ways to skin a cat)"으로의 접근 방법은 한 가지 방법이 다른 방법보다 낫다는 것을 의미하지 않는다는 것을 깨닫는 것이 중요하다.

이 스크립트 혹은 다른 스크립트에서 자립 실행으로 실행될 때와 다른 스크립트에서 실행될 때를 구분할 수 있는 스크립트를 만들기를 원한다면, 다음에서 보여주는 대로 시작 부분 근처에 조건 테스트를 추가하는 것을 고려해본다.

```shell
if [ "$BASH_SOURCE" = "$0" ]
```

약간의 실험 이후 나머지 코드를 작성하는 것은 연습으로 남겨둘 것이다.


>[!Note]
>254쪽의 스크립트 `#47`은 이 스크립트와 밀접한 관련이 있다. PATH의 디렉터리와 사용자 로그인 환경의 환경 변수를 모두 확인한다.

