
셸 스크립트 개발의 한 가지 문제는 일치하지 않는 데이터 포맷의 개수다. 이를 표준화하는 것은 다소 까다로운 일에서부터 매우 어려운 일까지 다양하다. 날짜는 매우 다양한 방식으로 지정할 수 있기 때문에 날짜 포맷은 작업하기 가장 어려운 작업 중의 하나다. 월-일년과 같은 특정 형식을 묻는 메시지를 보여주더라도 일치하지 않는 입력이 있을 수 있다. 월 이름 대신 월 숫자, 월 이름에 대한 약어 또는 전체 이름 대문자 등을 입력할 수 있다. 이러한 이유 때문에 날짜를 표준화하는 함수는 그 자체만으로 미숙할 수 있지만, 후속 스크립트 작업, 특히 84쪽의 스크립트 `#7`을 위해 매우 유용한 필수 요소가 될 것이다.


### 코드

리스트 1-5의 스크립트는 비교적 단순한 기준을 충족하는 날짜 포맷을 정규화한다. 월은 이름이나 1에서 12 사이의 값이어야 하며, 연도는 네 자리 값으로 주어져야 한다. 정규화 된 날짜는 세 자리 약자로 돼 있는 월의 이름과 그 다음 날짜, 네 자리 연도로 구성된다.


- [리스트 1-5]: normdate 셸 스크립트트
```shell

#!/bin/bash

# normdate -- 날짜 지정에서 월 필드를 세 자로 정규화하여, 첫 글자는 대문자다.

# 스크립트 #7의 날짜 검증에 대한 도움 함수다.

# 오류가 없으면 0으로 종료한다.

  
  

monthNumToName(){

# 'month' 변수를 적절한 값으로 설정한다.

case $1 in

1 ) month="Jan" ;; 2 ) month="Feb" ;;

3 ) month="Mar" ;; 4 ) month="Apr" ;;

5 ) month="May" ;; 6 ) month="Jun" ;;

7 ) month="Jul" ;; 8 ) month="Aug" ;;

9 ) month="Sep" ;; 10) month="Dec" ;;

11) month="Nov" ;; 12) month="Dec" ;;

* ) echo "$0: Unknown month value $1" >&2

exit 1

esac

# 다른 스크립트에서 monthNumToName()을 이용하려면 다음 문자의 주석을 풀어준다.

# echo $month $2 $3

return 0

}

  

# 메인 스크립트 시작 -- 다른 스크립트에서 이 스크립트를 포함시키려면,

# 이 줄 아래의 모든 내용을 삭제하거나 주석 처리하면 된다.

#=================

  

if [ $# -ne 3 ] ; then

echo "Usage: $0 month day year" >&2

echo "Formats are August 3 1962 and 8 3 1962" >&2

exit 1

fi

if [ $3 -le 99 ] ; then

echo "$0: expected 4-digit year value." >&2

exit 1

fi

  
  

# month 입력 포맷은 숫자인가?

if [ -z $(echo $1|sed 's/[[:digit:]]//g') ]; then

monthNumToName $1

else

# 처음 세 글자를 첫 번째는 대문자, 그다음은 소문자로 정규화한다.

month="$(echo $1|cut -c1|tr '[:lower:]' '[:upper:]')" #2

month="$month$(echo $1|cut -c2-3|tr '[:upper:]' '[:lower]' )" #3

  

fi

  

echo $month $2 $3

  

exit 0
```

### 동작 방식

위 스크립트의 `#1`에서 세 번째 조건을 확인해보자. 첫 번째 입력 필들에서 모든 자릿수를 제거한 후, `-z` 옵션을 사용해 결과가 비어 있는지 확인한다. 만약, 결과가 비어 있으면, 숫자만 입력된 것이므로 monthNumToName을 사용해 월 이름에 직접 매핑할 수 있다. 이 함수는 숫자가 유효한 월을 나타내는지의 여부도 확인한다. 그렇지 않으면, 첫 번째 입력이 월 문자열이라고 가정하고, 2개의 하위 셸 호출(즉, `$`로 둘러싸인 시퀀스며, 여기서 둘러싸인 명령이 호출돼 출력으로 대체된다)을 사용해 [[cut]] 및 [[tr]] 파이프의 복잡한 시퀀스로 정규화한다.

`#2`에서 첫 번째 서브 셸 시퀀스는 입력의 첫 번째 문자를 추출해 [[tr]]로 대문자를 만든다(시퀀스 `echo $1|cut -c1`은 앞서 살펴봤듯이 POSIX 방식인 `${1%${1#?}}`으로도 쓰여질 수 있다). `#3`에서 두 번째 시퀀스는 두 번째 및 세 번째 문자를 추출해 강제로 소문자를 만들어 month에 대해 대문자로 된 세 글자 약어를 표시한다. 이 문자열 조작 메서드는 월에 대해 숫자로 전달된 것과 달리, 입력이 실제로 유효한 달인지 여부를 확인하지 않는다.


### 스크립트 실행하기


이 스크립트는 normdate 기능을 포함하는 앞으로 나올 스크립트에서 최대한의 유연성을 보장하기 위해, [리스트 1-6]에서 보여주는 것처럼 명령 줄에 입력된 3개의 필드로 입력을 허용하도록 디자인됐다. 이 스크립트를 대화형으로만 사용하려는 경우, 사용자에게 세 가지 필드를 묻는 메시지가 표시되지만, 다른 스크립트에서 normdate를 호출하기가 더 어려워진다.


### 결과


- [리스트 1-6]: normdate 스크립트 테스트

```shell
┌──(kali㉿kali)-[~/Documents/bin]
└─$ normdate 8 3 1962
Aug 3 1962
                                                                                                                                                                                                                                           
┌──(kali㉿kali)-[~/Documents/bin]
└─$ normdate AUGUST 3 1962
Aug 3 1962

```

이 스크립트는 단지 월을 표현하는 것에 대해서만 정규화한다. 일 포맷(예를 들어, 0이 앞에 붙는) 및 연도는 그대로 유지된다.


### 스크립트 해킹하기

이 스크립트에 추가할 수 있는 많은 확장에 대해 관심을 갖기 전에, 보다 정교하게 만들기 위해 84 쪽의 스크립트 `#7`을 확인해보자. 이 스크립트는 입력된 날짜의 유효성을 검사하기 위해 normdate를 사용한다.

그러나 한 가지 수정을 한다면, 첫 번째 조건부 바로 앞에 다음 코드를 추가해 스크립트가 `MM/DD/YYYY` 또는 `MM-DD-YYYY` 포맷 날짜를 허용할 수 있게 해준다.

```shell
if [ $# -eq 1 ]; then
	set -- $(echo $1 | sed 's/[\/\-]/ /g')
fi
```

이 수정 사항을 통해, 다음과 같은 일반적인 포맷을 입력하고 정규화할 수 있다.

```shell
┌──(kali㉿kali)-[~]
└─$ normdate 6-10-2000     
Jun 10 2000
                                                                                                                                                                                                                                           
┌──(kali㉿kali)-[~]
└─$ normdate March-11-1911
Mar 11 1911
                                                                                                                                                                                                                                           
┌──(kali㉿kali)-[~]
└─$ normdate 8/3/1962     
Aug 3 1962

```

코드를 주의 깊게 읽으면, 다양한 국제 날짜 형식을 고려하지 않고 지정된 날짜의 연도를 확인하기 위한 좀 더 정교한 방식으로 향상될 수 있음을 알게 될 것이다. 이 부분에 대해 직접 체크하고 연습할 수 있도록 남겨둔다.


