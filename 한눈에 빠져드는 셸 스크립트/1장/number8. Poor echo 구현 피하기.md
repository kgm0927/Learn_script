
56쪽의 "[[POSIX란]]"에서 언급했듯이, 대부분의 현대적인 유닉스나 GNU/리눅스 구현에는 `-n` 플래그를 사용해 출력의 끝부분에 줄 바꿈을 막는 [[echo]] 명령어 버전이 있지만, 모든 구현이 그런 식으로 작동하는 것은 아니다. 어떤 사람들은 이 기본 동작을 무효화하기 위해 `\c`를 특별한 삽입 문자로 사용하고, 다른 사람들은 이런 후행 줄 바꿈을 어떤 상황에 관계없이 포함해야 한다고 주장했다.

특정 에코가 잘 구현됐는지 여부를 파악하려면 다음 명령을 입력하고 어떤 일이 발생하는지 확인하면 된다.

```shell
echo -n "The rain in Spain"; echo " falls mainly on the Plain" 
```

`-n` 플래그로 [[echo]]가 동작한다면, 다음과 같은 결과값을 볼 수 있다.

```shell
The rain in Spain falls Mainly on the Plain
```

그렇지 않으면 다음과 같이 출력된다.


```shell
-n The rain in Spain
falls mainly on the Plain
```

스크립트 출력이 원하는 대로 사용자에게 제공되는지 확인하는 것이 중요하며, 스크립트의 상호작용이 많을수록 중요해질 것이다. 이를 위해 echon이라는 [[echo]]의 대체 버전을 작성해 후행 줄 바꿈을 항상 막을 것이다. `echo -n` 기능을 원할 때마다 작성된 대체 버전을 호출할 수 있다.

---

### 코드

이 책에 있는 것처럼 이 기발한 echo 문제를 해결하는 데에는 여러 가지 방법이 있다. 우리가 좋아하는 것 중 하나는 간결함이다. [리스트 1-16]과 같이 awk printf 명령어를 통해 입력을 간단히 필터링한다.


- [리스트 1-16]: awk printf 명령어를 사용한 echo 대체 예제

``` shell
echon(){
echo "$*" | awk '{ printf "%s", $0 }'
}
```

그러나 awk 명령어를 호출할 때 발생하는 오버 헤드를 선호할지 모른다. 사용자 수준(user-level)의 [[printf]] 명령어를 사용한다면, [리스트 1-17]과 같이 echon을 대시 입력해 필터를 입력할 수 있다.



- [리스트 1-17]: 간단한 printf 명령어를 사용한 echo대체 예제
```shell
echon(){
printf "%s" "$*"
}
```


printf를 갖고 있지 않고 awk를 호출하지 않으려 한다면 다음 [[tr]] 명령어를 사용해 [리스트 1-18]과 같은 마지막의 캐리지 리턴(carriage return)을 잘라낼 수 있다.

- [리스트 1-18]: tr 유틸리티를 사용한 간단한 echo 대체 예제

```shell
echon()
{
echo "$*" | tr -d '\n'
}
```

이 방법은 간단하고 효과적이고 꽤 호환성이 있다.

---
### 스크립트 실행하기


스크립트 파일을 PATH에 추가하기만 하면, `echo -n` 호출을 echon으로 대체해 출력한 후 라인 끝부분에 사용자 커서를 확실하게 남길 수 있다.

---

### 결과

echon 셸 스크립트는 인자를 받아 화면에 보여준 후 동작하고, echon의 기능을 보여주기 위해 일부 사용자 입력값을 읽는다. 코드 [1-19]는 사용 중인 테스트 스크립트를 보여준다.

- [리스트 1-19]:echon 명령어 테스트

```shell
 kali@kali  ~/Documents/GitHub/learning_shell_script/bin   main  echon "Enter coordinate for satellite acquisition: "

Enter coordinate for satellite acquisition: % ( 아무리 해도 지금 사용자 커서가 나오지 않는다. 원래대로라면 12,34가 출력되어야만 했다. 나중에 다시 알아볼 것)  
```


---
### 스크립트 해킹하기

어떤 셸은 `-n` 플래그를 인식하고 셸은 \c를 종료 시퀀스로 기대하며, 일부 셸은 캐리지 리턴을 막을 수 있는 방법이 없다는 사실은 스크립터(scripter)에게 큰 고통이다. 이러한 불일치를 해결하기 위해 echo의 출력을 자동으로 테스트해 어떤 시나리오가 유효한지 결정한 후 해당 호출을 적절하게 수정하는 함수를 만들 수 있다. 예를 들어, `echo -n hi | wc -c`를 입력한 후, 결과가 두 문자(hi), 세 문자(hi plus 캐리지 리턴), 네 문자(-n hi) 또는 다섯 문자 (-n hi plus 캐리지 리턴)인지 테스트한다.


