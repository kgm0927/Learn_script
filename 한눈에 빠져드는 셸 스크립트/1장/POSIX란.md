
유닉스 초기에는 미국의 서부 개척 시대(wild West)와 같았다. 회사는 각기 다른 방향으로 운영 체제를 가져와 도입하면서, 동시에 이런 새로운 모든 버전들은 서로 그리고 다른 모든 유닉스와 마찬가지로 호환돼 고객을 확보하고 있다. 전기 전자 공학 연구소(Institute for Electrical and Electronic Enigneers, IEEE)가 참여했고, 모든 주요 유닉스 밴더가 엄청난 노력을 기울여 모든 상업 및 오픈소스 구현에 견줘 대항하기 위해 POSIX(Portable Operating System Interface)라고 부르는 유닉스용 표준 정의를 만들어냈다. POSIX 운영 체제 그 자체를 구입할 수 없지만, 사용하는 유닉스나 GNU/리눅스는 일반적으로 POSIX와 호환된다(GNU/f리눅스가 자체로 사실살 표준이 됐을 때, 심지어 POSIX 표준이 필요한지에 대해서도 논쟁이 있다).

동시에 POSIX 호환 유닉스의 구현이 다양할 수 있다. 한가지 예제로 이 장의 뒷부분에서 다룰 [[echo]] 명령어를 들 수 있다. 이 명령어의 일부 버전은 명령어 실행의 표준 사항인 후 행줄 바꿈(trailing newline)을 비활성화하는 `-n` 플래그를 지원한다. [[echo]]의 다른 버전은 특수한 "줄 바꿈 없음" 기능의 `\c` 이스케이프 시퀀스를 지원하지만, 다른 것들은 여전히 output의 끝에서 줄 바꿈(newline)을 할 수 밖에 없다. 좀 더 흥미로운 것은, 몇몇 유닉스 시스템은 `-n`과 `\c` 플래그를 무시하는 내장(built-in echo) 함수를 가진 명령 셸과 이 플래그들을 이해하는 자립 실행형(stand-alone) 바이너리 `/bin/echo`를 갖고 있다는 것이다. ==스크립트는 가능한 한 많은 유닉스 시스템에서 똑같이 동작해야 하기 때문에, 이러한 점은 셸 스크립트에서 입력 프롬프트를 어렵게 한다.== 따라서 함수형(functional) 스크립트의 경우, 시스템 전체에서 동일한 방식으로 동작하도록 echo 명령어를 표준화하는 것이 중요하다. 이 장 뒷부분에서(89쪽)의 스크립트 `#8`에서 셸 스크립트 내에 echo 명령어의 정규화된 버전을 만들기 위해 echo를 래핑하는 방법을 보여준다.

>[!note] 노트
>이 책의 일부 스크립트는 모든 POSIX 호환 셸에서 지원하지 않을 수 있는 bash 스타일 기능을 이용한다.

배경은 충분히 이야기했으므로 이제 자신만의 셸 스크립트를 라이브러리에 포함시킬 스크립트를 살펴보자.

