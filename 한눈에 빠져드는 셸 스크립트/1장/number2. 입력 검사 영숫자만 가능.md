

사용자는 지속적으로 지시를 무시하고 일관성이 없거나, 형식이 잘못됐거나, 잘못된 구문을 사용하는 데이터를 입력한다. 셸 스크립트 개발자는 이렇게 문제가 발생하기 전에 이러한 오류를 확인하고 표시해야 한다.

일반적인 경우는 파일 이름이나 데이터베이스 키와 관련된 상황이다. 프로그램은 사용자에게 구두점이나 특수 문자 그리고 공백을 허락하지 않고, 대문자, 소문자 및 숫자로 구성된 영 숫자로 문자열을 입력하라는 메시지를 입력한다. 유효한 문자열을 입력했는가? [리스트 1-3]에 있는 스크립트가 그것을 테스트하는 것이다.

### 코드

- [리스트 1-3]: validAlphaNum 스크립트

```shell

#!/bin/bash

# validAlphaNum -- 영문자와 숫자로만 입력되는지 확인한다.

  

validAlphaNum(){

  

# 인자 검증: 모든 입력이 대문자, 소문자 혹은 숫자일 때 0, 그렇지 않으면 1을 리턴한다.

  

# 사용할 수 없는 모든 문자를 제거

  

validchars="$(echo $1 | sed -e 's/[^[:alnum:]]//g')" #(1)

if [ "$validchars" = "$1" ] ; then #(2)

return 0

else

return 1

fi

}

  
  

# 메인 스크립트 시작 -- 다른 스크립트에서 이 스크립트를 포함시키려면,

# 이 줄 아래에 모든 내용을 삭제하거나 주석 처리하면 된다.

# ==============

/bin/echo -n "Enter input: "

read input

  

# 입력 유효성 검사

if ! validAlphaNum "$input" ; then

echo "Please enter only letters and numbers." >&2

exit 1

else

echo "Input is valid."

fi

  

exit 0
```

---

### 동작 방식

이 스크립트의 로직은 직관적이다. 먼저, 모든 잘못된 문자(1)를 제거하는 [[sed]] 기반 변환(sed-based-transform)을 사용해 입력된 정보의 새 버전을 만든다. 그런 다음, 새로운 버전을 원본(2)과 비교한다. 2개가 같으면 정상적인 입력인 것이다. 그렇지 않다면, sed 기반 변환에서 허용 가능한(영문자와 숫자) 문자 집합의 일부가 아닌 데이터를 잃어버렸고, 입력이 유효하지 않은 것이다.

이것은 [[sed]] 치환 동작이 모든 영숫자에 대한 POSIX 정규 표현 단축식인 `[:alnum:]`에 없는 문자를 제거하기 때문에 발생한다. 변환된 값이 이전에 입력한 원래의 입력과 일치하지 않으면, 입력 문자열에 영숫자가 아닌 값이 있음을 나타내므로, 입력이 유효하지 않음을 알려준다. 함수는 문제가 있는 것을 알려주기 위해 0이 아닌 결과를 리턴한다. ASCII 텍스트만을 기대하고 있음을 명심해야 한다.


---

### 스크립트 실행하기

이 스크립트는 자체로 동작되도록(self-contained)돼 있다. 입력을 묻는 메시지가 나타나면, 입력이 유효한지 알려준다. 그러나 이 함수를 보다 일반적으로 사용하는 경우는 다른 셸 스크립트의 맨 위에서 복사 혹은 붙여 넣거나 104쪽의 스크립트 `#12`처럼 라이브러리의 일부로 참조할 수 있다.

validAlphaNum은 또한 일반적인 셸 스크리브 프로그래밍 기술의 좋은 예다. 함수를 만든 후, 더 크고 복잡한 스크립트에 통합하기 전에 테스트해야 한다. 그렇게 하면 골칫거리를 많이 줄일 수 있다.


### 결과

validalphanum 셸 스크립트는 사용하기 쉽고, 사용자에게 유효성 검사를 위해 문자열을 입력 하도록 요청한다. [리스트 1-4]는 스크립트가 유효한 혹은 잘못된 입력을 처리하는 방법을 보여준다.


- [리스트 1-4]: validalphanum 스크립트 테스트
```shell

```



---
### 스크립트 해킹하기

"적당한 문자를 제거하고 남은 것을 확인하자"의 접근 방식은 유연하기 때문에 훌륭한 방법이 있다. 특히 비어 있는 값의 입력 오류를 피하기 위해 입력 변수와 매칭 패턴(또는 전혀 패턴이 없는)을 큰 따옴표를 묶어야 한다는 것을 기억하는 경우라면 더욱 좋다. 빈 패턴(empty patterns)은 유효 조건부 테스트(valid conditional test)를 오류가 있는 명령문으로 바꿔 오류 메시지를 생성하기 때문에 스크립팅에서 지속적으로 문제가 된다. 인용 부호가 없는 구문이 공백 구문과 다르다는 점을 항상 기억하는 것은 유용하다. 대문자를 사용하고 싶지만 공백, 쉼표 및 마침표로 허용할까? 간단히 (1)의 치환 패턴을 여기에 표시된 코드로 변경한다.

```shell
sed 's/[^[:upper:],.]//g '
```

또한 전화번호 입력을 검증하기 위해 다음과 같은 간단한 테스트를 사용할 수 있다(정수값, 공백, 괄호 및 대시는 허용하지만, 선행 공백이나 연달아 여러 공백을 허용하지 않음).
```shell
sed '[^-[:digit]\(\)]//g '
```

그러나 입력을 정수값으로 제한하려면 함정에 유의해야 한다. 예를 들어, 다음과 같이 시도해 볼 수 있다.

```shell
sed 's/[^[:digit:]]//g'
```

이 코드는 양수에서 동작한다. 만약, 음수를 입력할 수 있도록 하려면 어떻게 해야 하는가? 유효한 문자 세트에 마이너스 기호를 추가하기만 하면, -3-4가 분명히 정수는 아니지만, 유효한 입력이 된다. 75쪽의 스크립트 `#5`는 음수를 처리하는 방법을 설명한다.
