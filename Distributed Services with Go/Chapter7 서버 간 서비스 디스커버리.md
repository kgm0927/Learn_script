
지금까지 보안을 독립형(stand-alone) gRPC 웹 서비스를 만들었다. 이제 독립형을 넘어서서 분산 서비스를 만들어보자. <mark style="background: #ADCCFFA6;">서비스 디스커버리를 사용하면 클러스터에 노드를 자동으로 추가하고 삭제할 수 있다.</mark>

서비스 디스커버리를 처음 접하는 독자라도 7장을 다 읽고 나면 익숙해질 것이다. 서비스 디스커버리는 분산 서비스에서 가장 멋진 기능으로, 머신이 다른 머신을 자동으로 찾아준다. 스카이넷(Skyney)이 자신을 인식하고 제어하게 된다면, 분명 서비스 디스커버리가 중요한 역할을 했을 것이다. 서비스 디스커버리의 주요 이점부터 하나씩 알아보자.


---
# 7.1 서비스 디스커버리를 사용하는 이유

서비스 디스커버리는 서비스에 연결하는 방법을 알아내는 과정이다. 서비스 디스커버리는 **레지스트리**(registry) 목록을 항상 최신 상태로 유지해야 한다. 레지스트리는 서비스와 서비스의 위치, 그리고 서비스 이상 유무를 가진다. 다운스트림 서비스가 레지스트리를 질의하여 업스트림 서비스의 위치를 알아내고 연결한다. 예를 들자면, 웹 서비스가 데이터베이스를 찾아서 연결하는 것이다. 이렇게 하면 업스트림 서비스와 스케일 업, 스케일 아웃, 또는 교체되더라도 다운스트림 서비스는 여전히 이들과 연결할 수 있다.

클라우드 서비스가 없던 시절에는 '서비스 디스커버리'를 일일이 관리하고 고정된 주소로 설정할 수 있었다. 특정 하드웨어에서 애플리케이션이 돌아가기에 가능한 일이었다. 하지만, 작동하는 노드가 수시로 바뀌는 모던 클라우드 애플리케이션에서는 서비스 디스커버리가 중요한 역할을 한다.

서비스 디스커버리 대신 로드 밸런서를 서비스 앞쪽에 두는 개발자도 있다. 이때 로그 밸런서는 고정 IP를 가진다. 하지만 서버 간 통신에서는 본인이 서버를 제어하고, 로드 밸런서가 클라이언트와 서버 사이의 신뢰 범위(trust boundary) 역할을 할 필요가 없으므로 로드 밸런서 대신 서비스 디스커버리를 사용하는 편이 낫다. 로드 밸런서는 비용이 추가되고, 레이턴시가 증가하며, 단일 장애점(single failure)이 생기고, 스케일 업/스케일 다운을 할 때 업데이트해야 하는 단점이 있다. 수십~수백 개의 마이크로서비스를 관리할 때 서비스 디스커버리를 사용하지 않는다면 수십~수백 개의 로드 밸런서와 DNS 레코드를 관리해야 한다. 우리가 만드는 분산 서비스에 로드 밸런서를 사용한다면 엔진엑스(Nginx) 같은 로드 밸런서나 클라우드 로드 밸런서인 AWS의 ELB, GCP의 로드 밸런서를 사용해야 한다. 결국에는 운영 부담이 커지고 인프라스트럭처 비용과 레이턴시가 늘어난다.


우리 시스템에는 해결해야 할 두 가지 서비스 디스커버리 문제가 있다.

- 클러스터 내의 서버들이 어떻게 서로를 찾아낼 것인가?
- 클라이언트들은 어떻게 서버를 찾아낼 것인가?

7장에서는 서버 디스커버리를 구현하고, 8장에서는 합의 부분을 구현한 다음, 9장에서 클라이언트 디스커버리를 알아본다.

서비스 디스커버리가 무엇을 할 수 있는지 알아보았다. 이제부터 우리 서비스에 구현해보자.



---
# 7.2 서비스 디스커버리 넣어주기

서비스와 통신해야 하는 애플리케이션이라면, 서비스 디스커버리를 위한 도구에는 다음과 같이 기능이 필요하다.


- 서비스들에 대한 레지스트리(서비스의 IP나 포트 정보를 담고 있음) 관리하기
- 레지스트리를 이용해 서비스가 다른 서비스를 찾을 수 있도록 돕기
- 서비스 인스턴스가 잘 작동하는지 수시로 체크하고, 문제가 있다면 제거하기
- 서비스가 오프라인이면 등록 취소하기


지금까지 분산 서비스를 만든 사람들은 서비스 디스커버리를 위해 (콘술(Consul), 주키퍼(ZooKeeper), etcd 등) 별도의 독립적인 서비스를 사용해왔다. 이러한 아키텍처는 두 개의 클러스터를 가지는데, 하나는 **서비스 자체를 위한 클러스터**이고 다른 하나는 **서비스 디스커버리를 위한 클러스터**이다. 이렇게 했을 대 장점은 직접 서비스 디스커버리를 만들 필요가 없다는 것이다. 하지만, 서비스 사용자 입장에서는 서비스 디스커버리 클러스터에 관해 배우고 실행하며 작동시켜야 한다는 장점이 있다. 다시 말해, 직접 만들어야 하는 부담을 덜어서 서비스 사용자에게 지우는 셈이다. 이러한 부담 때문에 사용자는 줄어들고, 사용자들 역시 주위에 서비스를 추천하지 않게 된다.

그런데도 독립적인 서비스 디스커버리를 사용하여 분산 서비스를 만드는 사람이나 그러한 서비스를 사용하는 이들이 많다. 분산 서비스를 만들 때 서비스 디스커버리를 서비스에 넣어줄 수 있는 라이브러리가 없고, 사용자는 선택의 여지가 없기 때문이다.

다행스럽게도 고 언어 개발자들은 **서프**(serf) 라이브러리를 쓸 수 있다. 분산 클러스터 멤버십, 실패 감지, 오케스트레이션(orchestration)을 지원하여 분산 서비스에 서비스 디스커버리를 쉽게 추가할 수 있다. 실제로 하시코프 사는 서프를 만들어 자사 제품인 콘술에 대해 사용한다.

>[!note] 언제 독립형 서비스 디스커버리 설루션을 사용해야 할까?
>때로는 서비스 디스커버리를 위한 독립형 서비스가 필요하다. 예를 들어 여러 플랫폼에 서비스 디스커버리를 포함해야 할 때가 있다. 엄청난 노력과 시간이 필요한 작업으로, 콘술과 같은 서비스를 사용하면 손쉽게 해결할 수 있다. 이때 서브로 시작해보기를 추천한다. 서비스를 개발하여 풀려는 문제를 해결하고, 어느 정도 안정적으로 작동하게 되면 서비스 디스커버리 서비스를 사용해야 할지 판단할 수 있을 것이다.



서프로 서비스를 만들면 다음과 같이 추가 이점이 있다.

- 서비스 개발 초기에는 별도 서비스를 준비하는 것보다 빠르게 만들 수 있다.
- 독립형 서비스에서 서프로 바꾸기보다는 서프에서 독립형 서비스로 바꾸는 편이 훨씬 간단하므로 나중에 선택을 바꾸기도 쉽다.
- 서비스를 훨씬 쉽고 유연하게 배포할 수 있다. 덕분에 서비스 접근이 편리해진다.

이러한 이유로 서프를 사용하여 서비스 디스커버리를 만들어보려 한다.

서프의 이점은 알아보았으니 서프가 어떻게 작동하는지 알아보자.

---
