
==분산 서비스에서 서비스들은 네트워크로 통신한다.== ==구조체와 같은 데이터를 네트워크로 보내려면 우선 데이터를 전송할 수 있는 형태로 인코딩해야 한다.== 대표적인 형태가 JSON이다. public API 또는 클라이언트를 통제할 수 없는 프로젝트를 만든다면 JSON를 선택한다. JSON은 사람이 읽기에도 컴퓨터가 파싱하기에도 좋다. 하지만 private API 또는 클라이언트를 통제할 수 있는 상황이라면 JSON보다 더 나은 데이터 구조화와 전송 방식을 선택할 수 있다. 생산성이 더 높으면서도 빠르고 기능도 많으며 버그도 적은 서비스를 만들 수 있는 인코딩 방식 말이다.

그게 바로 **프로토콜 버퍼**(Protocol Buffers, 이하 protobuf)이다. 구글에서 만든 protobuf는 언어와 플랫폼에 상관없이 쓸 수 있고 확장할 수 있는, 데이터를 구조화하고 직렬화하는 메커니즘이다. protobuf의 장점은 다음과 같다.

- 자료형 안정성(type safety) 보장
- 스키마 위반 방지
- 빠른 직렬화
- 하위 호환성 제공

==protobuf를 사용하면 데이터 구조를 정의할 수 있고==, ==protobuf가 지원하는 많은 언어의 코드로 컴파일할 수 있으며, 이후 구조화된 데이터를 다른 데이터 스트림에 쓰거나 읽을 수 있다.== 프로토콜 버퍼는 마이크로서비스(microservice)와 같은 두 시스템 사이에서 통신하기에 좋다. 구글이 고성능 RPC 프레임워크를 개발하고자 gPRC를 만들 때 protobuf를 사용한 이유이다.

protobuf를 써본 적이 없다면 추가 작업이 너무 많다고 생각할 수 있다. 하지만 이번 2장부터 책을 읽어가며 계속 protobuf를 써본다면 점점 더 마음에 들 것이다. JSON보다 장점이 많으며 결국은 해야 할 일이 줄어든다.

간단한 예제를 살펴보자. 예제는 프로토콜 버퍼가 어떤 모양이고 어떻게 작동하는지를 보여준다. 트위터(twitter)에서 일하며 Tweets 객체 유형(object type)을 다뤄야 한다고 상상해보자. Tweets는 최소한 작성자의 메시지가 있어야 한다. protobuf로 정의하면 다음과 같다.

```proto

syntax="proto3";

package twitter;

message Tweet{
string message=1;
}
```

이제 원하는 언어로 컴파일해야 한다. 예를 들어 protobuf 컴파일러는 다음과 같은 go 코드를 생성할 것이다.


```proto
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: example.proto

package twitter

type Tweet struct{
Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
// 참고: Protobuf는 내부 필드와 메서드도 생성하는다
// 여기서는 생략했다.

}
```

하지만 왜 직접 go 코드를 짜지 않는 걸까? ==protobuf를 쓰는 이유는 무엇일까? 지금부터 알아보자.==

---
# 2.1 프로토콜 버퍼를 쓰는 이유

protobuf는 다음과 같은 여러 유용한 기능을 제공한다.


#### 2.1.1 일관된 스키마

==protobuf로 의미하는 바(semantics)를 인코딩하고 서비스 전반에 걸쳐 사용하면 전체 시스템의 일관성이 보장된다.== 필자가 일한 회사들은 마이크로서비스를 사용했는데, 당시 동료들과 함께 **인프라스트럭처**를 만들었다. =='structs'라는 저장소를 두고 protobuf와 컴파일한 코드를 모아두었으며 모든 서비스가 여기에 의존하게 했다.== 덕분에 여러 개의 일관성이 없는 스키마를를 제품에 사용할 위험을 없앨 수 있었다. 또한, ==go 언어의 자료형 검사 덕분에 구조체 의존성을 업데이트하고 변경한 데이터 모델을 테스트할 수 있었다.== ==컴파일과 테스트를 마치면 스키마의 일관성에 문제가 없는지 확인할 수 있다.==

### 2.1.2 버전 관리 제거

구글이 protobuf를 만든 이유 중 하나는 버전을 확인할 필요성을 없애고 다음과 같은 지저분한 코드 작성을 피하려는 것이었다.

``` go

// StructureDataWithProtobuf/example.go

if (version == 3){

}else if(version > 4){

if(version == 5){

}
}
```


protobuf 메시지(protobuf message)를 Go 구조체라고 생각하자. 메시지를 컴파일하면 구조체가 된다. ==protobuf에서는 메시지의 필드마다 번호를 매기는데, 새로운 기능을 내놓거나 변경할 때 하위 호환성을 관리하려는 것이다.== 덕분에 새로운 필드를 추가하기 쉽고, 파싱하고 전달만 하는 중간 서버는 모든 필드를 알 필요가 없다. ==필드를 제거할 때는 더 이상 사용하지 않는 필드에 'reserved'라고 표시만 하면, 컴파일할 대 해당 필드를 사용하려는 코드가 있는지 체크해준다.==


#### 2.1.3 줄어드는 보일러플레이트 코드

컴파일로 생성한 protobuf 라이브러리에 인코딩과 디코딩 메서드가 만들어진다. 직접 관련 코드를 짤 필요가 없다.


#### 2.1.4 확장성 

protobuf 컴파일러는 확장을 지원한다. 자신만의 컴파일 로직으로 protobuf를 컴파일할 수 있다는 뜻이다. 예를 들어 여러 구조체가 공통의 메서드(method)를 가지게 하려면, protobuf에서 자동으로 해당 메서드를 생성하는 플러그인을 만들 수 있다.


#### 2.1.5 언어 불가지론

protobuf는 많은 언어를 지원한다. protobuf 버전 3.0 이후로 C++, go, java, python, 루비, C#, 오브젝티브-C, PHP를 지원하며 서드파티들이 다른 언어들을 지원해주기도 한다. 서로 다른 언어로 만들어진 서비스 간에 통신할 때 별도의 작업도 필요 없다. 이러한 언어 불가지론(language agnosticism)은 여러 언어로 개발하려는 다양한 팀이 있는 회사에서, 또는 팀이 사용하는 언어를 다른 언어로 바꾸려는 상황에서 매우 유용하다.

#### 2.1.6 성능

고성능이며 페이로드(payload)가 적고, 직렬화할 대 JSON보다 6배 빠르다. gRPC는 API 정의 및 메시지 직렬화에 프로토콜 버퍼를 사용한다. 우리가 만들 서버와 클라이언트에도 gRPC를 쓸 것이다.

이 정도면 protobuf가 상당히 좋다고 판단될 것이다. 그래도 따분한 이론보다는 실전이다. protobuf를 생성하고 이를 이용해서 빌드해보자.

---
# 2.2 프로토콜 버퍼 컴파일러 설치하기

프로토콜 버퍼 컴파일러를 설치해보자. 깃허브의 protobuf릴리스(배포) 페이지에서 설치하려는 컴퓨터에 맞는 릴리스를 다운로드하자. 이 책에서는 macOS(지금 나는 리눅스에서 하고 있다) protoc-3.19.4-osx-x86_64.zip를 다운로드한다. 터미널에서 다음과 같이 설치할 수 있다.

``` shell

┌──(kali㉿kali)-[~/Downloads]
└─$ wget https://github.com/protocolbuffers/protobuf/\
releases/download/v3.19.4/protoc-3.19.4-linux-x86_64.zip
--2024-12-03 01:02:29--  https://github.com/protocolbuffers/protobuf/releases/download/v3.19.4/protoc-3.19.4-linux-x86_64.zip
github.com (github.com) 해석 중... 20.200.245.247
다음으로 연결 중: github.com (github.com)|20.200.245.247|:443... 연결했습니다.
HTTP 요청을 보냈습니다. 응답 기다리는 중... 302 Found
위치: https://objects.githubusercontent.com/github-production-release-asset-2e65be/23357588/6436bdf6-2887-4abb-973e-90dcefb6b5ac?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20241203%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20241203T060228Z&X-Amz-Expires=300&X-Amz-Signature=cc0bd5c361f7cb4129b5e8eba20d9857b06fd31ae28306aa59194a31aba9ff33&X-Amz-SignedHeaders=host&response-content-disposition=attachment%3B%20filename%3Dprotoc-3.19.4-linux-x86_64.zip&response-content-type=application%2Foctet-stream [따라감]
--2024-12-03 01:02:31--  https://objects.githubusercontent.com/github-production-release-asset-2e65be/23357588/6436bdf6-2887-4abb-973e-90dcefb6b5ac?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20241203%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20241203T060228Z&X-Amz-Expires=300&X-Amz-Signature=cc0bd5c361f7cb4129b5e8eba20d9857b06fd31ae28306aa59194a31aba9ff33&X-Amz-SignedHeaders=host&response-content-disposition=attachment%3B%20filename%3Dprotoc-3.19.4-linux-x86_64.zip&response-content-type=application%2Foctet-stream
objects.githubusercontent.com (objects.githubusercontent.com) 해석 중... 185.199.110.133, 185.199.108.133, 185.199.109.133, ...
다음으로 연결 중: objects.githubusercontent.com (objects.githubusercontent.com)|185.199.110.133|:443... 연결했습니다.
HTTP 요청을 보냈습니다. 응답 기다리는 중... 200 OK
길이: 1699853 (1.6M) [application/octet-stream]
저장 위치: `protoc-3.19.4-linux-x86_64.zip'

protoc-3.19.4-linux-x86_64.z 100%[=============================================>]   1.62M  1.72MB/s    /  0.9s    

2024-12-03 01:02:36 (1.72 MB/s) - `protoc-3.19.4-linux-x86_64.zip' 저장함 [1699853/1699853]


┌──(kali㉿kali)-[~/Downloads]
└─$ unzip protoc-3.19.4-linux-x86_64.zip -d ~/.local/protobuf
Archive:  protoc-3.19.4-linux-x86_64.zip
   creating: /home/kali/.local/protobuf/include/
   creating: /home/kali/.local/protobuf/include/google/
   creating: /home/kali/.local/protobuf/include/google/protobuf/
  inflating: /home/kali/.local/protobuf/include/google/protobuf/wrappers.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/source_context.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/struct.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/any.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/api.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/descriptor.proto  
   creating: /home/kali/.local/protobuf/include/google/protobuf/compiler/
  inflating: /home/kali/.local/protobuf/include/google/protobuf/compiler/plugin.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/timestamp.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/field_mask.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/empty.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/duration.proto  
  inflating: /home/kali/.local/protobuf/include/google/protobuf/type.proto  
   creating: /home/kali/.local/protobuf/bin/
  inflating: /home/kali/.local/protobuf/bin/protoc  
  inflating: /home/kali/.local/protobuf/readme.txt  


┌──(kali㉿kali)-[~/Downloads]
└─$ rm ./protoc-3.19.4-linux-x86_64.zip
                                                                                                                   
┌──(kali㉿kali)-[~/Downloads]
└─$ 


```


**protobuf** 디렉토리를 보면 다음과 같다.

```shell
┌──(kali㉿kali)-[~/Downloads]
└─$ tree ~/.local/protobuf
/home/kali/.local/protobuf
├── bin
│   └── protoc
├── include
│   └── google
│       └── protobuf
│           ├── any.proto
│           ├── api.proto
│           ├── compiler
│           │   └── plugin.proto
│           ├── descriptor.proto
│           ├── duration.proto
│           ├── empty.proto
│           ├── field_mask.proto
│           ├── source_context.proto
│           ├── struct.proto
│           ├── timestamp.proto
│           ├── type.proto
│           └── wrappers.proto
└── readme.txt

6 directories, 14 files

```

**bin** 디렉터리에는 **protoc**이라는 컴파일러 바이너리가 있고, ==include 디렉터리에는 protobuf의 표준 라이브러리라 할 수 있는 protobuf 파일들이 있다.== 컴파일러 바이너리만 설치하고 include 디렉토리의 protobuf 파일들을 설치하지 않는 경우가 많은데, 그러면 제대로 컴파일되지 않는다.

설치가 끝났으면 PATH 환경 변수에 추가하여 어디서든 실행할 수 있도록 하다. zsh를 사용한다면 다음과 같이 설정한다.

```shell

(굳이 작성하진 않겠음)

```

protobuf 컴파일러가 제대로 설치되었는지 `$ protoc --version` 명령으로 확인해보자. 에러 없이 버전 정보가 제대로 출력된다면 protobuf 작성하고 컴파일할 준비가 끝났다.


---
# 2.3 프로토콜 버퍼로 도메인 자료형 정의하기


1장에서 Record 자료형을 다음과 같은 Go 구조체로 정의했다.

``` go

// LetsGo/internal/server/log.go

type Record struct {
	Value  []byte `json:"value"`
	Offset uint64 `json:"offset"`
}

```


이를 protobuf 메시지로 바꾸려면 go 코드를 protobuf 문법에 맞게 바꿔주어야 한다.

go 프로젝트에서는 보통 api 디렉터리에 protobuf를 둔다. 터미널에서 다음 명령으로 프로젝트 디렉터리와 api/v1 디렉터리를 만들자.


```shell

$mkdir -p StructureDataWithProtobuf/api/v1
```

해당 디렉터리에 log.proto 파일을 만들고 다음 코드를 추가하자.


``` proto
syntax = "proto3";

package log.v1;

option go_package = "github.com/Part2-StructureDataWithProtobuf/api/log/v1";

message Record {
    bytes value = 1;
    uint64 offset = 2;
}
```

protobuf 코드를 들여다보자. 우선 현재 최신 버전인 proto3을 사용한다고 명시했다. 그리고 패키지명을 명시했는데, 이 이름은 생성된 go 코드의 패키지명으로 쓰이며, 같은 이름을 가진 메시지 자료형 사이의 충돌을 막아준다.

protobuf 메시지는 앞에서 언급한 Go 구조체와 대응한다. 두 문법이 매우 비슷하다는 걸 알 수 있다. Go 구조체가 protobuf 메시지이며 둘 다 필드(field)로 이루어진다. Go에서는 필드명이 왼쪽, 자료형이 오른쪽이지만, protobuf에서는 자료형이 왼쪽, 필드명이 오른쪽이며 ID까지 넣어준다.

패키지 선언을 한 다음에 Record 자료형을 정의한다. ==프로토콜 버퍼에서는 repeated 키워드를 사용해 자료형의 슬라이스를 정의한다.== 따라서 repeated Record는 records 필드가 go 코드로는 `[]Record` 자료형이라는 의미이다.

앞서 protobuf는 유용한 기능으로 필드에 버전을 부여할 수 있다고 설명했다. ==각각의 필드는 자료형과 이름, 그리고 고유(unique)한 필드 번호를 가진다.== ==직렬화하면 해당 번호 필드 번호가 해당 필드의 ID가 된다.== 따라서 프로젝트에서 protobuf 메시지를 쓰기 시작했다면 필드 번호를 바꾸면 안 된다. 필드를 불변이라 생각하자. 필드를 바꿀 수는 없고, 예전 필드의 사용을 멈추고 새로운 필드를 사용하는 것이다. 단순히 기능이나 데이터를 메시지에서 추가하거나 살제하는 작고 반복적인 변경이라면 이렇게 사용하자.

메시지들은 메이저 버전으로 구분할 수 있다. 인프라스트럭처 전체의 아키텍처를 새롭게 하거나 마이그레이션을 위해 여러 메시지 버전을 동시에 운영하려할 때 메이저 버전을 이용한다. 대부분의 경우에는 필드 버전으로 충분하므로 메이저 버전에 따른 충돌 문제는 거의 없다. 필자도 메이저 버전 충돌 문제는 딱 두 번 겪었는데, 구글의 API 정의에 따르면 그들도 두어 번 경험했다. 메이저 버전을 바꾸는 건 매우 드문 일이지만, 필요할 때를 대비해 알아두자.

앞서 log.proto 파일을 `api/v1` 디렉터리에 넣으라고 설명했다. 여기서 v1이라는 디렉터리명이 메이저 버전을 뜻한다. 프로젝트를 계속 만들어가다가 API 호환성을 깨기로 했다면 v2 디렉터리를 만들고 새로운 메시지를 추가한다. 그리고 사용자들에게 호환성이 전혀 없는 API 변경이 있음을 알려준다.

이제 log.proto 파일을 컴파일하여 go 코드를 생성해보자.

---
# 2.4 프로토콜 버퍼 컴파일하기


protobuf를 원하는 프로그래밍 언어로 컴파일하면 해당 언어의 런타임이 필요하다.

go는 이 작업을 위한 두 개의 런타임이 있다. 구글의 Go팀과 protobuf 팀이 먼저 런타임을 개발했다. 그리고 좀 더 많은 코드 생성 기능과 더 빠른 직렬화 및 역직렬화를 원했던 외부 팀이 이를 포크(fork)하여 gogoprotobuf를 개발했다. etcd, 메소스(Mesos), 쿠버네티스, 도커, 코크로치DB(CockroachDB), NATS와 같은 프로젝트들과 드롭박스(Dropbox), 센드그리드(Sendgrid)와 같은 회사들이 gogoprotobuf를 사용한다. 필자 역시 프로젝트들을 쿠버네티스 프로토콜 버퍼에 통합하고 추가 기능을 사용하고자 gogoprotobuf를 사용했다.

2020년 3월, Go 팀은 프로토콜 버퍼를 위해 성능을 향상한 Go API(APIv2)라는 메이저 버전과, gogoprotobuf처럼 기능을 추가할 수 있는 리플렉션(reflection) API를 배포했다.  gogoprotobuf를 사용하던 프로젝트들은 APIv2로 마이그레이션하기 시작했다. 성능이 더 낫기도 했고, 새로운 reflection API과 gogoprotobuf가 호환되지 않은 점을 해결해야 했으며, gogoprotobuf 프로젝트에 새로운 오너십이 필요하기도 했다. 현재로서는 APIv2를 사용하기를 추천한다.

protobuf를 go로 컴파일하려면 protobuf 런타임부터 설치해야 한다.

```shell
┌──(kali㉿kali)-[~]
└─$ go install google.golang.org/protobuf/...@latest  
go: downloading google.golang.org/protobuf v1.35.2
go: downloading github.com/google/go-cmp v0.5.5
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ 



```

이제 프로젝트 루트에서 다음 명령어를 실행하면 protobuf를 컴파일할 수 있다.

```shell
$ proto api/v1/*.proto \
--go_out=. \
--go_opt=paths=source_relative \
--proto_path=.
```

`api/v1` 디렉터리에 log.pb.go 파일이 생성되었다. 파일을 열어보면 컴파일러가 protobuf 파일로부터 생성한 go 코드를 볼 수 있다. protobuf 메시지가 Go 구조체로 생성되었고, 구조체를 protobuf 바이너리 와이어 포맷(binary wire format)으로 직렬화해주는 메서드들과 필드 값을 가져오는 getter들도 생성되었다.

protobuf가 바뀔 때마다 컴파일해야 하므로 Makefile 파일에 compile 이라는 타깃을 만들어두면 편리하다. 만드는 김에 테스트를 위한 test 타깃도 만들자. 프로젝트의 루트 디렉토리에 다음과 같이 **Makefile** 파일을 만들자.

```shell
// StructureDataWithProtobuf/Makefile
compile:
proto api/v1/*.proto \
--go_out=. \
--go_opt=paths=source_relative \
--proto_path=.

test:
go test -race ./...
```

컴파일을 거쳐 고 코드까지 생성해보았다. 이제 생성한 코드를 이용하는 방법과, 컴파일러를 확장하여 자신만의 코드를 만드는 방법을 알아보자.


---
# 2.5 생성한 코드를 이용하여 작업하기

`log.pb.go`는 1장에서의 log.go 보다 훨씬 긴데, 직렬화를 구현한 코드들도 있기 때문이다. 하지만 사용하는 방법은 다르지 않다. 예를 들어 & 연산자(또는 new 키워드)를 이용해 인스턴스를 생성하고, 마침표(.)를 이용하여 필드에 접근한다.

컴파일러는 생성한 구조체에 다양한 메서드를 함께 생성한다. 다만, ==직접적으로 getter들만 사용한다. 구조체 필드에 직접 접근할 수 있다면 그래도 되지만, 여러 메시지에 같은 getter들이 있고 이를 인터페이스로 추상화하고 싶다면 getter가 유용하게 쓰인다.== 예를 들어보자. 아마존(Amazon) 같은 판매 사이트를 만들고 책이나 게임 등 여러 종류의 상품을 판매한다고 가정하자. 상품들은 모두 가격 필드가 있다. 고객의 장바구니에 있는 상품들의 총액을 계산하고 싶다면 어떻게 할까? 먼저 Pricer라는 인터페이스를 만들고 Total이라는 함수가 슬라이스를 매개변수로 받도록 한다. 코드는 다음과 같다.

```go
type Book struct{
Price uint64
}

func (b *Book) GetPrice() uint64{
// ...
}

type Game struct{
Price uint64
}

func(b *Game) GetPrice()uint64{
// ...
}

type Pricer interface{
GetPrice() uint64
}

func Total(item []Pricer) uint64{
// ...
}

```

이번엔 모든 상품의 가격을 변경하는 스크립트를 짠다고 생각해보자. 리플렉션(reflection)을 사용할 수도 있지만, go의 격언에서 '리플렉션은 명확하지 않다(reflection is never clear)'라고 했듯이 리플렉션은 가능한 한 사용을 피해야 한다. 만약 setter 만 있다면 다음과 같은 인터페이스를 만들어서 여러 종류의 상품의 가격을 변경할 수 있다.

``` go
type PriceAdjuster interface{
SetPrice(price uint64)
}
```

컴파일로 생성한 코드만으로 부족할 때는 플러그인을 사용해서 확장할 수 있다. 이 프로젝트에서는 플러그인이 필요 없지만, 필자는 몇몇 프로젝트에서 플러그인을 작성하여 유용하게 사용한 경험이 있다. 플러그인 작성법을 배워두면 언젠가는 많은 수작업을 플러그인으로 해결하게 될 것이다.


---
# 2.6 마치며

2장에서는 protobuf의 기초를 다루었다. 실습 프로젝트에서 계속 사용할 것이다. 이 개념은 특히 프로젝트에서 gRPC 클라이언트와 서버를 만들 때 매우 중요하다.

이제 우리 프로젝트에서 또 하나의 중요한 요소인 커밋 로그 라이브러리를 만들어보자.