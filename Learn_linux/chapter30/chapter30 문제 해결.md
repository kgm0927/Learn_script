
### 이제는 스크립트를 좀 더 복잡하게 만들어, 실수를 했을때나 프로그램이 원치 않는 동작을 할 때 무슨 일이 벌어지는지 살펴볼 차례다. 이 장에서는 스크립트에서 발생하는 흔한 오류들과 문제를 찾아 해결하는 방법들을 살펴볼 예정이다.

---
# 구문 오류

일반적인 오류 분류 중 하나는 **구문적인 것**이다. 구문 오류에는 쉘 구문 요소의 잘못된 타이핑을 포함한다. 대부분 이러한 오류는 스크립트를 실행하는 경우 쉘에 혼란을 일으킬 수 있다.

다음에서, 일반적인 오류를 보여주기 위해 이 스크립트를 사용할 것이다.

```shell
#!/bin/bash

# trouble: script to demonstrate common errors

number=1


if [ $number = 1 ]; then
        echo "Number is equal to 1."
else
        echo "Number is not equal to 1."
fi

```

이 스크립트는 성공적으로 실행된다.

```shell
┌──(kali㉿kali)-[~]
└─$ ./trouble
Number is equal to 1.

```


### 따옴표 누락

```shell
#!/bin/bash

# trouble: script to demonstrate common errors

number=1

if [ $number = 1 ]; then
        echo "Number is equal to 1.
else
        echo "Number is not equal to 1."
fi
          
```

무슨 일이 벌어졌는지 알아보자.

```shell
┌──(kali㉿kali)-[~]
└─$ ./trouble
./trouble: line 10: unexpected EOF while looking for matching `"'
  
```

두 가지 오류가 발생한다. 흥미롭게도, 프로그램에서 따옴표가 누락된 곳이 아닌 그 이후의 핸 번호를 보고한다.(다만 현재 나타난 대로 지금은 누락된 곳을 나타낸다) 프로그램의 누락된 따옴표 이후를 따라가보면 왜 그런지 알 수 있다. bash는 나머지 마침 따옴표를 찾을 때까지 계속되고 두 번째 echo 명령어 이후에 바로 나타난다. 그 이후에 bash는 매우 혼란스러워하고 if 명령의 문법은 깨져버린다. 그것은 fi 문이 인용된(열리기만 한) 문자열에 포함되기 때문이다.

장문의 스크립트에서는 이러한 종류의 오류를 발견하기란 여간 어려운 일이 아니다. 하지만 편집기에서 문법 하이라이팅 기능을 사용하면 도움이 될 수 있다. 만약 [[chapter12 VI 맛보기|vim]]의 완전한 버전이 설치되어 있다면, 문법 하이라이팅은 다음 명령으로 활성화할 수 있다.


`:syntax on`


### 예상치 못한 토큰이나 토큰 누락

또 다른 흔한 실수는 [[chapter27 흐름 제어 if 분기|if]]나 [[while]] 문처럼 합성 명령어를 제대로 완료하지 않는 것이다. if 명령어에서 테스트 후에 세미콜론을 제거하면 무슨 일이 벌어지는지 살펴보자.

```shell
#!/bin/bash

# trouble: script to demonstrate common errors

number=1

if [ $number = 1 ] then
        echo "Number is equal to 1."
else
        echo "Number is not equal to 1."
fi
    
```

결과는 이렇다.

```shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ ./trouble
./trouble: line 9: syntax error near unexpected token `else'
./trouble: line 9: `else'

```


또 다시 오류 메시지는 실제 문제가 발생한 지점 이후를 오류로 가리킨다. 꽤 재미있는 일이 벌어졌다. if가 명령어 목록을 받아서 마지막 명령의 종료 코드를 검사한다는 것을 상기해보자. 이 프로그램의 [[test]]와 동의어인 `[`의 단일 명령어로 구성된 목록은 의도된 것이다. `[` 명령어는 인자 목록이 뒤이어 온다. 여기서는 4개의 인자(`$number, =, 1, ]`)가 따라온다. 세미콜론 제거로 `then`은 인자 목록에 추가된다. 이는 문법적으로 유효하다. 그 다음 [[echo]] 명령어도 유효하다. 명령어 목록에서 [[chapter27 흐름 제어 if 분기|if]]가 종료 코드를 평가할 다른 명령어로 해석된다. 그 다음 만나게 되는 것은 else이지만 쉘이 그것을 명령어 이름이 아닌 **예약어**(쉘에서 특수한 의미를 가진 단어)로 인식하기 때문에 적합하지 않다. 결국 오류 메시지는 이 때문이다.


### 예상 외의 확장

스크립트에서 간헐적으로 발생하는 오류도 있다. ==스크립트는 종종 확장의 결과로 인해 제대로 동작하다가도 어느 시점에는 실패할 것이다.== 우리는 다음과 같이 제거한 세미콜론을 되돌리고 **number**의 값을 빈 변수로 변경할 것이다.

```shell
┌──(kali㉿kali)-[~]
└─$ cat trouble
#!/bin/bash

# trouble: script to demonstrate common errors

number=

if [ $number = 1 ] then
        echo "Number is equal to 1."
else
        echo "Number is not equal to 1."
fi

```

변경된 스크립트를 실행하면 결과는 다음과 같다.

```shell

┌──(kali㉿kali)-[~]
└─$ ./trouble  
./trouble: line 7: [: =: unary operator expected
Number is not equal to 1.

```

우리는 꽤 아리송한 오류 메시지를 얻게 되고 뒤이어 두 번째 echo 명령의 결과가 따라온다. 이 문제는 test 명령 내의 number 변수의 확장으로 인한 것이다. 그 명령어 

```shell
[ $number = 1 ]
```

number가 빈 값으로 확장되면, 그 결과를 이렇다.

```shell
[ = 1 ]
```

이는 유효하지 않으며 오류를 만든다. = 연산자는 이항 연산자(양쪽에 값이 필요한)인데 첫 번째 값이 없기 때문에 , test 명령어는 대신 단항 연산자 (-z 과 같은)를 요구한다. 게다가 test가 실패했기 때문에(오류로 인해) if 명령어는 0이 아닌 종료 코드를 받게 되고 그에 따라 행동한다. 그리고 두 번째 echo 명령어가 실행된다.

이 문제는 test 명령의 첫 번째 인자 주위를 따옴표로 감싸면 해결할 수 있다.

```shell
[ "$number" = 1 ]
```

그러면 다음과 같이 확장될 것이다.

```shell
[ ""=1]
```

올바른 인자 수가 전달된다. 인용은 빈 문자열에 사용하는 것 외에도, 스페이스를 포함한 파일명처럼 여러 단어로 되 문자열을 확장하는 경우에도 사용해야 한다.


---
# 논리 오류

구문 오류와 달리, **논리 오류**는 실행 중에 스크립트를 막지는 않는다. 정상적으로 논리적인 문제 때문에 원하는 결과를 얻을 수 없을 것이다. 수많은 논리적 오류가 가능하지만 여기서는 스크립트에서 흔히 발견되는 몇 가지 오류들만 살펴볼 것이다.

- **잘못된 조건식**: `if/then/else` 문은 잘못된 로직을 수행하는 부정확한 코드를 만들기 쉽다. 때때로 로직이 반대로 되어 있거나 볼완전할 것이다.
- **"Off by one"** **오류들**: 카운트를 사용하여 루프를 코딩할 때, 올바른 지점에서 카운트가 종료되기 위해서 1이 아닌 0부터 루프가 시작한다는 것을 간과하는 경우가 있다. 이러한 종류의 오류는 카운트가 초과해서 "끝을 지나는" 루프가 생길 수 있고 또한 반복이 하나 일찍 종료되어 루프의 마지막 반복을 놓칠 수도 있다.
- **예상치 못한 상황**: 대다수 논리 오류는 프로그램이 프로그래머가 예상치 못한 데이터나 상황을 맞닥뜨리게 한다. 또한 스페이스가 포함된 파일명처럼 예상치 못한 확장도 이러한 부류에 포함될 수 있다. 이는 단일 파일명이 아닌 복수 명령어 인자들로 확장된다.


### 방어적 프로그래밍

프로그래밍을 할 때 가정을 검증하는 것은 중요하다. 이는 프로그램들과 스크립트에서 사용되는 명령어들의 종료 상태를 평가함에 있어 주의해야 한다는 것을 의미한다. 여기 사실에 기반을 둔 예제가 있다. 불운한 시스템 관리자가 중요 서버에 유지 작업을 수행하기 위해 스크립트를 작성했다. 이 스크립트는 다음과 같이 단 두줄로 이루어져 있다.


```shell

cd $dir_name
rm *
```

디렉토리명 변수 dir_name이 실재하는 한 본질적으로 이 두 줄이 잘못된 것은 없다. 하지만 그렇지않다면 어떻게 될까? 그런 경우에 cd 명령은 실패하고 스크립트는 다음 줄로 이동하여 현 작업 디렉토리의 모든 파일들을 삭제한다. 결코 원하던 결과가 아니다! 그 불행한 관리자는 이러한 설계로 인해 서버의 중요 부분을 망가뜨렸다.

좀 더 개선할 수 있는 방법을 찾아보자. 먼저, cd의 성공 여부에 따라 rm을 실행하도록 바꾸는 것이 현명할 것 같다.

```shell
cd $dir_name && rm *
```

이 방식에서 [[cd]] 명령이 실패하면 [[rm]] 명령은 실행되지 않는다. 이는 더 나은 방식이지만, 여전히 dir_name 변수가 설정되지 않거나 비어있어 사용자 홈 디렉토리의 파일들이 삭제되는 결과를 얻게 될 가능성이 존재한다. 이것 또한 dir_name이 실제 존재하는 디렉토리를 포함하는지 검사하여 피할 수 있다.

```shell
[[ -d $dir_name ]] && cd $dir_name && rm *
```

보통 이 상황하에서는 스크립트가 오류와 함께 종료되는 것이 최선이다.

```shell
if [[ -d $dir_name ]]; then
	if cd $dir_name; then
			rm *
	else
			echo "cannot cd to '$dir_name'" >&2
			exit 1
	fi
else
	echo "no such directory: '$dir_name'" >&2
	exit 1
fi
```

이제 우리는 그 이름과 존재하는 디렉토리인지 두 가지 모두를 검사한다. 만약 실패해도 자세한 오류 메시지가 표준 출력으로 전해지고 스크립트는 실패를 가리키는 종료 상태 1과 함께 종료된다.


### 입력 값 검증

==프로그램이 입력을 받는 경우 일반적으로 좋은 프로그래밍 규칙은 어떤 입력 값이든 처리 가능해야 한다는 것이다.== 이는 항상 추가적인 처리를 위해 꼭 유효한 입력만을 허용하도록 주의 깊게 확인해야 한다. 우리는 이전 장의 read 명령어를 학습할 때 이 예제를 보았다. 메뉴 선택을 검증하기 위해 테스트를 포함하는 스크립트를 말이다.

```shell
[[^[0-3]$ ]]
```

이 테스트는 매우 특별하다. 사용자가 0부터 3까지의 수를 문자열로 반환했다면 종료 상태 0을 반환할 것이다. 그 외는 아무것도 허용되지 않을 것이다. 때대로 이러한 테스트를 작성하는 것이 매우 힘들 수도 있지만 고급 스크립트를 만들기 위해서는 필수불가결한 노력이다.


>[!tip] 디자인은 시간에 비례한다.
>필자가 산업 디자인을 배우던 대학생 시절. 현명한 한 교수님께서 프로젝트의 디자인 등급은 디자이너에게 주어진 시간의 양에 의해 결정된다고 말씀하셨다. 만약 여러분에게 파리를 죽이는 기구를 설계하는 데 5분의 시간이 주어졌다면, 아마 파리채를 설계했을 것이다. 만약 다섯 달이 주어졌다면, 레이저 유도 방식의 "안티 플라이 시스템(anti-fly system)"을 만들었을 것이다.
>동일한 원칙이 프로그래밍에도 적용된다. 때때로 프로그래머에 의해 오직 한 번만 사용되는 "간이" 스크립트라면 어떨까? 이러한 종료의 스크립트는 흔하고 약간의 노력으로 빠르게 개발될 수 있을 것이다. 이러한 스크립트들은 많은 주석과 방어적 코딩이 필요 없다. 반면에, **실사용**을 위한 스크립트, 즉 여러 사용자들과 중요한 업무에 반복적으로 사용되는 스크립트라면 좀 더 주의 깊게 개발되어야 한다.

---
# 테스팅

테스팅은 모든 종류의 소프트웨어 개발에서 중요한 단계다. 물론 스크립트도 포함해서 말이다. 오픈소스 세계에는 이 사실을 반영한 "**빠른 출시, 잦은 출시**(release early, release often)"라는 말이 있다. 빠르고 잦은 출시로 인해 소프트웨어는 더 많이 테스팅 및 사용된다. 경험은 버그들을 찾기 쉽게 해준다. 그리고 개발 단계에서 일찍 버그를 발견하게 되면 수정하는 비용도 덜 든다.



### 스텁(stub)

이전 논의에서 우리는 스텁이 프로그램을 검증하기 위해 어떻게 사용될 수 있는지 보았다. 그것들은 스크립트 개발의 최초 단계에서 작업의 절차를 확인하기 위해 가치 있는 기법이다.

이 전 파일 삭제 문제를 살펴보고 이를 쉽게 테스트하기 위해 어떻게 코딩하는지 보자. 원본 코드 조각은 파일들을 삭제하기 때문에 테스트하는 것은 위험할 수도 있다. 따라서 우리는 그 코드를 안전하게 테스트할 수 있게 수정할 것이다.

```shell
if [[ -d $dir_name ]]; then
	if cd $dir_name; then
		echo rm * # TESTING
	else
		echo "cannot cd to '$dir_name'" >&2
		exit 1
	fi

else
	echo "no such directory: '$dir_name'" >&2
	exit1
fi
exit # TESTING
```

오류 조건식에는 이미 유용한 메시지가 출력되었기 때문에, 우리가 더 이상 추가할 필요가 없다. 가장 중요한 변화는 [[rm]] 명령어 바로 앞에 [[echo]] 명령어가 놓인 것이다. 이는 그 명령어를 허용하지만 실행하는 대신에 그 확장된 인자 목록이 표시된다. 이 변경은 코드의 안전한 수행을 위한 것이다. 코드 조각의 끝 부분에 테스트를 완료하고 스크립트의 나머지 부분에서 실행되는 것을 막기 위해 exit 명령을 두었다. 이것은 스크립트의  설계에 따라 다양할 것이다.

또한 테스트와 관련된 변경을 위해 "마커(markers)"로 동작하는 약간의 주석을 포함한다. 이것들은 테스트가 끝났을 때 변경 내역을 찾아 제거하는 데 도움을 줄 수 있다.



### 테스트 케이스

효과적인 테스트를 위해 좋은 **테스트 케이스**를 개발하고 적용하는 것 또한 중요하다. ==테스트 케이스는 **엣지 케이스**(edge casee)와 **코너 케이스**(corner case)를 반영하여 입력 데이터와 작동 상태를 주의 깊게 선택하는 것으로 이뤄진다.== 우리는 앞서 사용한 코드(매우 간단한) 에서 다음 세 가지 조건하에서 코드가 어떻게 수행되는지 알아보려고 한다.


- dir_name이 존재하는 디렉토리를 포함한 경우.
- dir_name이 존재하지 않는 디렉토리를 포함한 경우.
- dir_name이 비어있는 경우.

이들 조건을 각각 테스트하여 좋은 **테스트 커버리지**를 만들 수 있다.

디자인과 마찬가지로 테스팅도 시간에 비례한다. 모든 스크립트 기능을 광범위하게 테스트할 필요는 없다. 가장 중요한 것이 무엇인지 확인하는 것이 정말 중요하다. 만약 코드가 오동작하면 큰 피해를 입을 수 있기 때문에, 그 설계와 테스팅 둘 다 타당한지 신중하게 숙고해야 한다.


---
# 디버깅

테스팅에서 스크립트의 문제가 드러나면, 다음 단계는 디버깅이다. 어떤 면에서 "문제"란 항상 프로그래머의 예상대로 수행되지 않는 스크립트를 의미한다. 만약 이러한 경우라면, 스크립트가 실제 어떻게 동작하고 왜 그러지 주의 깊게 확인할 필요가 있다. 버그를 발견하는 일은 때때로 탐색 작업을 포함할 수 있다.

잘 짜인 스크립트는 도움이 될 것이다. 그것은 비정상적인 상태를 감지하고 사용자에게 유용한 피드백을 제공하기 위해 방어적으로 구성될 수 있다. 하지만 때때로 이상하고 예상치 못한 문제들이 발생하고 해결하기 위해 많은 기술을 필요로 한다.


### 문제 발생 지역 발견

특히 긴 스크립트에서 문제가 되는 스크립트 영역을 종종 격리하는 게 유용하다. 항상 실제 오류는 아닐 수 있지만 코드 분리는 실제 원인에 대한 실마리를 제공할 것이다. 코드를 격리시키는 데 쓰이는 한 가지 기법은 스크립트 일부를 주석화하는 것이다. 예를 들면, 파일 삭제 코드는 오류와 연관된 영역이 제거되었는지 확인하기 위해 다음과 같이 수정될 수 있다.

```shell
if [[ -d $dir_name ]]; then
	if cd $dir_name; then
			rm *
	else
			echo "cannot cd to '$dir_name'" >&2
			exit 1
	fi
	# else
	#      ehco "no such directory: '$dir_name'" >&2
	#      exit 1
fi
```

스크립트 논리 영역의 각 행의 시작 부분에 주석 기호를 두어서 그 영역이 실행되는 것을 막는다. 그러고 나서 버그에 영향을 주는 코드가 제거되었는지 다시 테스팅을 한다.


### 트레이싱(tracing)


버그는 종종 스크립트 내의 예상치 못한 논리적 흐름이 경우가 있다. ==즉 스크립트의 일부가 전혀 실행되지 않거나 잘못된 시간 혹은 잘못된 순서로 실행되는 경우다.== 프로그램의 실제 흐름을 보기 위해 우리는 **트레이싱**(tracing)이란 기법을 사용한다.

트레이싱의 한 가지 방법은 스크립트 내에 실행 위치를 표시하는 정보 메시지를 포함시키는 것이다. 우리 코드에 이러한 메시지를 추가할 수 있다.

```shell
echo "preparing to delete files" >&2
if [[ -d '$dir_name' ]]; then
        if cd $dir_name; then
echo "deleting files" >&2
                rm *
        else
                echo "cannot cd to '$dir_name'" >&2
                exit 1
        fi
else
        echo "no such directory: '$dir_name'" >&2
        exit 1
fi
echo "file deletion complete" >&2


```

**일반적으로 출력과 그 메시지들을 구분하기 위해 표준 오류로 전달한다.** 또한 메시지를 포함한 행들을 들여쓰지 않는다. 그래서 그것들을 제거하려 할 때 좀 더 찾기 쉬워진다.

이제  스크립트가 실행되면, 파일 삭제의 진행 과정을 확인할 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ ./deletion-script
preparing to delete files
deleting files
file deletion complete(이 부분은 현재 코딩으로 나오지 않는다. 그러므로 직접 적는다.)
```

==또한 bash는 **-x** 옵션이나 [[printenv|set]] 명령어에 -x 옵션으로 트레이싱 방법을 제공한다.== 우리는 초기의 문제 있는 스크립트에 -x 옵션을 첫 줄에 추가하여 스크립트 전체를 추적할 수 있다.

```shell
#!/bin/bash -x

# trouble: script to demonstrate common errors

number=1

if [ $number = 1 ]; then
        echo "Number is equal to 1."
else
        echo "Number is not equal to 1."
fi

```

실행 결과는 다음과 같다.

```shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ ./trouble  
+ number=1
+ '[' 1 = 1 ']'
+ echo 'Number is equal to 1.'
Number is equal to 1.
                           
```

트레이싱을 활성화하여 확장이 적용된 명령어를 보게 된다. 더하기 기호는 일반적인 출력과 구별하여 트레이스 출력을 가리킨다.  더하기 기호는 트레이스 출력의 기본 문자다. 그것은 PS4(프롬프트 문자열 4) 쉘 변수에 포함한다. 이 변수의 내용은 프롬프트를 더 유용하게 만들기 위해 조절이 가능하다. 이제, 우리는 스크립트에서 트레이스가 실행되는 곳의 행 번호를 포함하기 위해 수정한다. 프롬프트가 실제 사용될 때까지 확장되는 것을 악기 위해 따옴표가 필요하다는 것을 명심해야 한다.

```shell
┌──(kali㉿kali)-[~]
└─$ export PS4='$LINENO + '
                            
┌──(kali㉿kali)-[~]
└─$ ./trouble              
5 + number=1
7 + '[' 1 = 1 ']'
8 + echo 'Number is equal to 1.'
Number is equal to 1.
                       
```

스크립트 전체가 아닌 선택된 영역에 트레이스를 수행하기 위해 [[printenv|set]] 명령어와 -x 옵션을 사용할 수 있다.

```shell
#!/bin/bash 

# trouble: script to demonstrate common errors

number=1

set -x # Turn on tracing
if [ $number = 1 ]; then
        echo "Number is equal to 1."
else
        echo "Number is not equal to 1."
fi
set -x # Turn off tracing
  
```

set 명령어와 -x 옵션을 사용하여 트레이싱을 활성화하고 다시 +x 옵션으로 비활성화한다. 이 기법은 골칫거리인 스크립트의 여러 부분을 검사하기 위해 사용될 수 있다.


### 실행 중에 값 확인

이것은 트레이싱과 마찬가지로, 때때로 실행 중에 스크립트의 내부 동작을 확인할 변수의 내용을 표시하는 경우 유용하다. [[echo]] 문의 추가로 이 트릭을 사용할 것이다.

```shell
┌──(kali㉿kali)-[~]
└─$ cat trouble            
#!/bin/bash 

# trouble: script to demonstrate common errors

number=1

set -x # Turn on tracing
if [ $number = 1 ]; then
        echo "Number is equal to 1."
else
        echo "Number is not equal to 1."
fi
set -x # Turn off tracing

┌──(kali㉿kali)-[~]
└─$ ./trouble  
number=1
9 + '[' 1 = 1 ']'
10 + echo 'Number is equal to 1.'
Number is equal to 1.
14 + set -x
               

```

이 간단한 예제에서는 number 변수의 값을 표시할 뿐만 아니라 나중에 식별해서 제거하기 쉽도록 해당 줄을 주석으로 표시한다. 이 기법은 특히 스크립트 내의 루프와 연산의 동작을 확인할 때 유용하다.

---
# 마무리 노트


이 장에서 우리는 스크립트 개발 중에 나타나는 몇몇 문제들을 살펴봤다. 물론 더 많은 경우가 존재한다. 여기서 설명한 기법들은 가장 흔한 버그를 찾아준다. 디버깅은 버그를 예방하는 경우(개발 전반에 걸쳐 지속적인 테스팅)와 찾는 경우(트레이싱을 활용), 두 가지 경험을 통해 개발된 수 있는 하나의 예술이라 할 수 있다.