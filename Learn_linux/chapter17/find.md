
다양한 방법으로 파일 찾기

locate 프로그램은 오로지 파일명에 근거하여 파일을 찾을 수 있지만 find 프로그램은 다양한 속성에 근거하여 주어진 디렉토리(하위 디렉토리에 포함하여)를 검색하여 파일을 찾는다. 향후 프로그래밍 개념을 다루게 될 때 이 명령어를 반복적으로 사용하게 되기 때문에 find에 대해서 깊이 있게 다루려고 한다. 

가장 단순한 예제로 find에 검색할 디렉토리명을 함께 입력해본다. 예를 들어 홈 디렉토리 내용을 검색해볼 수 있다.

``` shell

┌──(kali㉿kali)-[~]
└─$ find ~  
```

대부분은 사용자 계정에서는 엄청난 양의 결과를 보여줄 것이다. 이 결과는 표준 출력으로 보내기 때문에 파이프라인을 이용하여 다른 프로그램과 함께 사용할 수 있을 것이다. 파일 개수를 세어보기 위해 [[wc]] 명령어를 사용해보자.

``` shell
┌──(kali㉿kali)-[~]
└─$ find ~ | wc -l
5984
        
```

엄청난 수다. find의 훌륭한 점이 바로 특정 조건에 부합하는 파일을 찾을 수 있다는 것이다. find는 **테스트**, **액션**, **옵션**을 적용하여 검색할 수 있다. 이 중에서 테스트부터 살펴보자.

### 테스트

검색 결과에서 디렉토리 목록만을 보고 싶을 대, 다음과 같은 테스트를 덧붙여볼 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ find ~ -type d | wc -l
1027

```

-type d라는 테스트를 추가해서 디렉토리 검색으로 제한한 것이다. 역으로, 이 테스트를 활용하여 일반 파일만을 검색하게도 할 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ find ~ -type f | wc -l
4952
     
```

- **표 17-1**
파일 형식 찾기

| 파일 형식 | 설명        |
| ----- | --------- |
| b     | 블록 특수 파일  |
| c     | 문자 특수 파일  |
| d     | 디렉토리      |
| f     | 파일        |
| l     | 심볼릭 링크 파일 |

또한, 다른 테스트를 활용하여 파일 크기와 파일명을 검색할 수 있다. 예를 들면, 와일드카드 패턴 `*.jpg`와 일치하면서 1메가바이트보다 큰 파일을 검색해보자.

``` shell
┌──(kali㉿kali)-[~]
└─$ find ~ -type f -name "*.JPG" -size +1M | wc -l
0

```

이 예제에서는 *-name*이라는 테스트를 사용했고 이어 와일드카드 패턴을 추가했다. 여기서 주목할 점은 쉘에 의한 경로명 확장을 막기 위해서 쌍 따옴표 안에 패턴을 입력한 부분이다. 그 다음 *-size* 테스트를 *+1M* 조건과 함께 추가하였다. 여기서 플러스 기호는 지정된 숫자보다 큰 크기의 파일을 찾는다는 것을 의미한다. 마이너스 기호가 앞에 오면, 해당 숫자보다 작은 파일 크기를 지정하는 것이다. 플러스나 마이너스 기호가 없다면, 그 숫자와 정확하게 일치하는 크기의 파일을 찾는다는 것이다. 숫자 다음에 나오는 M이란 글자는 파일 크기를 메가바이트 단위로 지정한 것이다. 다음의 **표 17-2**에서 파일 크기를 지정할 때 사용되는 단위를 살펴보도록 하자.

- 표 17-2 파일 크기 단위


| 기호  | 크기 단위             |
| --- | ----------------- |
| b   | 512바이트 단위의 블록(단위) |
| c   | 바이트               |
| w   | 2바이트 크기의 워드       |
| k   | 킬로바이트(1024바이트)    |
| M   | 메가바이트(2^32바이트)    |
| G   | 기가바이트(2^32바이트)    |

find 명령어는 수많은 종류의 테스트를 지원한다. [표 17-3]에서 자주 사용되는 테스트에 대한 확인해보자. 숫자 인자를 지정해야 하는 경우에, 앞서 말한 + 기호와 -기호가 동일한 의미로 적용됨을 기억하도록 하자.

- [표 17-3] find의 테스트의 예제


| 테스트               | 설명                                                                                                                                                  |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| -cmin n           | 정확히 n분 전에 마지막으로 내용이나 속성이 변경된 파일 또는 디렉토리를 검색, n분을 기준으로 이전/이후의 시간을 설명할 때 -/+ 기호를 사용한다, 예) -n, +n                                                      |
| -cnewer *file*    | *file*보다 더 최근에 마지막으로 내용이나 속성이 변경된 파일 또는 디렉토리를 검색                                                                                                    |
| -ctime n          | `n*24`시간 전에 마지막으로 내용이나 속성(예: 권한)이 변경된 파일 또는 디렉토리 검색                                                                                                 |
| -empty            | 빈 파일이나 디렉토리 검색                                                                                                                                      |
| -group *name*     | *name* 그룹에 속한 파일 또는 디렉토리 검색. *name*은 그룹명이나 숫자로 된 그룹 ID로 지정한다.                                                                                       |
| -iname *patttern* | *-name* 테스트와 동일하지만 대소문자를 구분하지 않는다.                                                                                                                  |
| -inum *n*         | *n*번 inode에 해당하는 파일 검색. 특정 노드상에 있는 모든 하드 링크를 검색할 때 유용하다.                                                                                            |
| -mmin *n*         | *n*분 전에 내용이 변경된 파일 또는 디렉토리를 검색                                                                                                                      |
| -mtime *n*        | `n*24`시간 이전에 내용만이 변경된 파일 또는 디렉토리를 검색                                                                                                                |
| -name *pattern*   | 지정된 와일드카드 패턴과 일치하는 파일과 디렉토리를 검색                                                                                                                     |
| -newer *file*     | 지정된 *file*보다 최근에 내용이 변경된 파일과 디렉토리를 검색. 파일 백업을 위한 스크립트 작성 시에 유용하다. 백업을 만들 때마다, 파일(로그 파일)을 업데이트한 후 find를 이용하여 최근 업데이트 시기 이후에 어떠한 파일이 변경되었는지 알아볼 수 있다. |
| -nouser           | 유효 사용자에게 속하지 않는 파일과 디렉토리를 검색. 삭제된 계정에 속한 파일을 찾거나 침입작의 행동을 감지하기 위해 사용될 수 있다.                                                                         |
| -nogroup          | 유효한 그룹에 속하지 않는 파일과 디렉토리를 검색                                                                                                                         |
| -perm *mode*      | 지정된 *mode*로 퍼미션이 설정된 파일 또는 디렉토리를 검색. *mode*는 8진법이나 심볼릭 기호로 표현된다.                                                                                    |
| -samefile *name*  | *-inum* 테스트와 유사한 것으로 *name*이란 파일과 같은 inode 번호를 공유하는 파일을 검색해준다.                                                                                      |
| -size *n*         | *n* 크기의 파일 검색                                                                                                                                       |
| -type *c*         | *c* 형식의 파일 검색                                                                                                                                       |
| -user name        | *name* 사용자에 속한 파일 또는 디렉토리를 검색, *name*은 사용자명이나 숫자로 된 사용자 ID로 표현된다.                                                                                   |


이것이 다가 아니다. **find**의 man 페이지에서 전체 내용을 확인할 수 있다.

---

### 연산자

find 명령어가 지원하는 모든 테스트들조차도 테스트 간의 **논리적인 관계**를 설명하기 위한 더 좋은 방법이 필요할 수도 있다. 예를 들면, 디렉토리 내의 모든 파일과 하위 디렉토리가 안전한 권한을 가지고 있는지 확인해야 할 경우, 해당 파일들의 퍼미션이 0600으로 설정되어 있지 않은지 그리고 디렉토리 퍼미션이 0700으로 설정되어 있지 않은지를 확인해야 할 것이다. 다행히도 find 프로그램은 이보다 복잡한 논리적 관계를 설정할 수 있도록, **논리 연산자**를 사용하여 테스트들을 결합하는 방법을 제공한다. 앞서 언급한 테스트 상황을 표현하기 위해서 다음과 같은 할 수 있다.


``` shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)


```

굉장히 이상해 보인다. 이게 다 뭘 하는 걸까? 사실, 연산자를 활용하는 것은 일단 사용법을 알고나면 그렇게 복잡하지만은 않다(표 17-4 참고).

- [표 17-4] find의 논리 연산자


| 연산자  | 설명                                                                                                                                                                                                                                                                                                              |
| ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -and | 연산자를 기준으로 양쪽 테스트 조건이 모두 참인 반면에, -a로 줄여 쓸 수 있다. 연산자가 사용되지 않았을 경우, -and가 기본값으로 적용된다.                                                                                                                                                                                                                              |
| -or  | 연산자를 기준으로 양쪽 테스트 중 하나라도 참인 경우에 검색, -o로 줄여 쓸 수 있다.                                                                                                                                                                                                                                                               |
| -not | 연산자 다음에 나오는 테스트가 거짓인 경우에 검색. -!로 줄여 쓸 수 있다.                                                                                                                                                                                                                                                                     |
| ()   | 테스트와 연산자를 조합하여 표현한 내용을 하나로 그룹화할 때 사용된다. 논리 계산의 우선순위를 정하기 위한 것으로 기본적으로 find 명령어는 왼쪽에서 오른쪽으로 계산을 수행한다. 하지만 원하는 결과를 얻기 위해서 기본적인 계산 순서를 무시해야 할 경우가 종종 있다. 필요한 상황이 아니더라도 때론 명령어의 가독성을 높이기 위해 사용되기도 한다. 괄호는 쉘에서 특별한 의미를 갖고 있다는 사실을 명심하자. 커맨드라인에서 사용할 때는 반드시 인용 부호를 사용해야 find의 명령 인자로 인식될 수 있다. 보통은 백슬래시를 괄호와 함께 사용한다. |


이 논리 연산자를 활용하여 앞의 예제에서 쓰인 find 명령어를 분석해보도록 하자. 일단 가장 중요한 부분부터 살펴보면 *-or* 연산자를 중심으로 크게 두 그룹으로 구성되어 있는 것을 볼 수 있다.

*(expression 1) -or (expression 2)*

이 부분은 어렵지 않게 이해할 수 있다. ==왜냐하면 우리는 애초에 파일에 설정된 권한 그리고 디렉토리에 설정된 권한 내용을 각각 검색하려고 했기 때문이다.== 그렇다면 왜 두 경우를 모두 찾으려고 하는데 -and 연산자가 아닌 -or 연산자를 사용한 것일까? 그 이유는 find 명령어가 파일과 디렉토리를 모두 탐색하면서 지정된 테스트에 대한 일치 여부를 하나하나 계산하기 때문이다. 우리는 **각각**의 경우가 잘못된 권한으로 설정된 파일인지 **또는** 디렉토리인지 알고 싶다. 따라서 파일이면서 디렉토리인 경우는 될 수 없다. 그러면 그룹별 표현으로 확장하여 다음과 같이 다시 분석해 보자.

*(file with bad perms) -or (directory with bad perms)*

다음으로 우리가 이해해야 할 부분은 "잘못된 퍼미션"을 테스트하는 법이다. 잘못된 퍼미션을 어떻게 알 수 있을까? 사실 방법이 없다. 우리가 테스트해야할 것은 **"올바르지 않은 퍼미션"** 이다. 그 이유는 "올바른 퍼미션"을 알고 있기 때문이다. 파일의 경우 올바른 경우가 0600으로 권한설정이 되어 있다는 것이고, 디렉토리는 0700으로 설정된 것이다. 올바르지 않는 퍼미션을 가진 파일을 테스트하는 식은 다음과 같다.

 *-type f -and -not -perm 0600*

디렉토리에 대해서는,

*-type d -and -perms 0700*

이다.

[표 17-4]에 나와 있듯이, -and 연산자는 기본값이기 때문에 생략할 수 있다. 따라서 분석한 내용을 하나로 모아보면 최종으로 사용할 명령어 표현은 다음과 같을 것이다.

*find ~ (-type f -not -perms 0600) -or (-type d -not -perms 0700)*

여기서, 괄호는 쉘에서 특수한 의미를 갖고 있기 때문에 쉘이 이를 혼동하지 않도록 괄호 앞에서 백슬래시를 함께 사용해야 한다.

- [표 17-5] find 명령어의 AND/OR 연산자 로직


| expr1 수행 결과 | 연산자  | expr2 수행여부 |
| ----------- | ---- | ---------- |
| 참           | -and | 실행 o       |
| 거짓          | -and | 실행 X       |
| 참           | -or  | 실행 X       |
| 거짓          | -or  | 실행 O       |

왜 이런 것일까? 그것은 검색 기능을 개선하기 위해서다. *-and*의 경우를 살펴보자. *epxr -and expr2*이란 표현은 *expr1*표현이 거짓인 경우 참이 될 수 없다. 따라서 *expr2* 표현을 수행할 필요가 전혀 없는 것이다. 마찬가지로 *expr1 -or expr2*의 경우에 *expr1*이 참이라면 *expr2*를 실행하지 않아도 *expr1 -or expr2*표현이 참임을 알 수 있다.

그렇다. 검색 가능성이 좋아졌다. 그렇다면 왜 이 부분이 중요한 것일까? 그 이유는 앞으로 보게 되겠지만 액션을 수행하는 방법을 제어할 때 이러한 동작에 의존하기 때문이다.


---

### 액션

자, 이제 본격적으로 작업을 해 보도록 하자. find 명령의 결과 목록은 유용하지만 우리가 정말로 하고자 하는 것은 해당 목록에 있는 항목을 동작하는 것이다. 다행히도 find는 검색 결과를 토대로 액션을 구현할 수 있다.

##### 미리 정의된 액션

액션에는 미리 정의된 액션과 사용자 지정의 핵션이 있다. 우선 [표 17-6]에서 미리 정의된 액션 몇 가지를 살펴보자.

- [표 17-6] 미리 정의된 find 액션


| 액션      | 설명                                                          |
| ------- | ----------------------------------------------------------- |
| -delete | 현재 검색된 파일을 삭제한다.                                            |
| -ls     | 검색된 파일에 대하여 ls -dils와 같은 명령을 실행. 출력은 표준 출력으로 전송된다.          |
| -print  | 검색 결과의 전체 경로명을 표준출력으로 출력한다. 별도의 액션을 설정하지 않을 경우 이 액션이 기본값이다. |
| -quit   | 검색 조건에 해당하는 결과가 하나라도 나올 경우 검색 종료.                           |

테스트처럼, 활용할 수 있는 액션도 아주 많다. find의 man 페이지에서 자세한 내용을 확인해보자. find를 활용한 첫 번째 예제에서 우리는 다음과 같이 말했다.

``` shell
find ~
```

이 명령은 홈 디렉토리에 있는 모든 파일 및 하위 디렉토리를 목록으로 보여준다. ==사실 이것은 -print 액션이 함축된 것이다. 다른 어떤 액션도 지정되지 않았고, print 액션이 기본값이기 때문에 해당 결과를 출력한 것이다.== 따라서 다음과 같이 표현할 수도 있다.

```shell
find ~ -print
```

특정 조건에 해당하는 파일을 삭제하는 데 find 명령어를 사용할 수도 있다. 예를 들어 .BAK(백업파일) 확장자를 가진 파일을 삭제하고 싶다면 다음과 같이 명령을 실행할 수 있다.

``` shell

┌──(kali㉿kali)-[~]
└─$ find ~ -type f -name '*.BAK' -delete             
```

이 예제에서는 사용자의 홈 디렉토리에 있는 모든 파일에 대하여 .BAK으로 끝나는 파일명을 검색한다. 해당 파일들을 찾게 되면 모두 삭제될 것이다.

>[!tip] 저자주
>-delete 액션을 사용할 경우 아무런 메시지 없이 액션을 실행되기 때문에 **극도록 주의**를 기울여야 한다. 따라서 -delete를 사용하기 전에 -print 액션을 먼저 사용하여 명령어 결과를 확인하도록 하자.


더 진행하기에 앞서 논리 연산자가 액션에 어떤 영향을 주는지에 대해서도 살펴보도록 하자. 다음 명령을 보자.

``` shell                                    
┌──(kali㉿kali)-[~]
└─$ find ~ -type f -name '*.BAK' -print 

```

이 명령은 .BAK(-name '`*.BAK'`)으로 끝나는 모든 파일을 찾은 후 그 결과를 상대 경로명으로 표준 출력에 출력할 것이다(-print). 하지만 이런 식으로 명령이 실행되는 이유는 각 테스트와 액션 사이에 존재하는 논리 연산자에 의해 결정되기 때문이다. -and 논리 연산자는 기본값으로 수행되고 있다는 사실을 기억하라. 함축된 이 연산자를 표시하여 조금 더 좋게 명령을 표현해보자.

``` shell
┌──(kali㉿kali)-[~]
└─$ find ~ -type f -and -name '*.BAK' -and -print

```

이 명령에 대해서 논리 연산자가 어떤 식으로 실행하는 데 영향을 주게 되는지 [표 17-7]에서 알아보자.


- [표 17-7] 논리 연산자 효과


| 테스트/액션          | 수행되는 경우                                         |
| --------------- | ----------------------------------------------- |
| -print          | -type f와 -name `'*.BAK'` 결과가 참인 경우.             |
| -name `'*.BAK'` | -type f가 참인 경우.                                 |
| -type f         | 이 표현은 항상 수행된다. 그 이유는 -and 관계에서 첫 번째 표현식이기 때문이다. |

논리 표현식은 어떤 표현을 수행할지를 결정하기 때문에 수행되는 순서가 중요함을 알 수 있다. 예를 들면, 테스트 및 액션 수행 순서를 바꿔서 -print 액션이 먼저 실행되고자 했다면 명령은 아주 다르게 표현되었을 것이다.

``` shell
find ~ -print -and -type f -and -name '*.BAK'
```

이 표현은 각 파일 (-print 액션은 항상 참이다)을 출력하고 파일 형식과 지정된 파일 확장자에 대하여 테스트를 수행할 수 있다.

---
### 사용자 정의 액션

미리 정의된 액션뿐만 아니라 임의의 명령어를 실행할 수도 있다. 대표적인 것으로 *-exec* 액션을 활용한 명령인데 다음과 같다.

*-exec command {} ;*

*command*자리에는 명령어의 이름이 들어가고, {} 기호에는 현재 경로명에 대한 심볼릭 링크를 표시한다. 세미콜론은 명령어의 끝을 말해주는 구획 기호로 꼭 필요하다. 조금 전에 살펴본 -delete 액션과 동일한 기능을 하는 -exec 액션 예제가 있다.

``` shell
-exec rm '{}' ';'
```

중괄호와 세미콜론 기호는 쉘에서 특수한 의미로 사용되기 때문에 반드시 인용되거나 확장되어야 한다.
``` shell
┌──(kali㉿kali)-[~]
└─$ find ~ -type f -name 'foo.*' -ok ls -l '{}' ';'


```

이 예제에서 우리는 foo 문자열로 시작하는 이름을 가진 파일을 검색한다. 그리고 파일을 찾을 때 마다 ls -l 명령을 실행한다. -ok 액션은 ls 명령의 실행 여부에 대해 확인하는 메시지를 띄운다.


---
### 능률 올리기

-exec 액션을 사용하면, 일치하는 파일이 발견될 때마다 지정된 명령을 매번 실행한다. 그런데 모든 검색 결과를 합쳐 한 번에 명령어를 실행하고 싶을 때가 있다. 예를 들면, 다음과 같이 명령을 실행하는 것이 아니라,

ls -l *file1*
ls -l *file2*


다음과 같이 한 번에 실행하는 것을 더 좋아할 수도 있다.


ls -l *file1 file2*

명령어를 반복적으로 수행하는 것이 아니라 단 한번만 실행되도록 하자. 두 가지가 있다. 일반적인 방법으로는 xargs라는 외부 명령어를 사용하는 것이고, 대안으로는 find가 가지고 있는 새로운 기능을 활용하는 것이다. 우선 대안법부터 알아보자.

일단 맨 마지막의 세미콜론 기호 대신 ==+ 기호==를 사용하자. ==그러면 원하는 명령이 한 번에 실행될 수 있도록 검색 결과들을 인자 목록으로 묶어주는 find 기능이 활성화된다.== 이전 예제는 다시 불러보자.

``` shell
                                                                                                                    
┌──(kali㉿kali)-[/]
└─$ find ~ -type f -name 'foo*' -exec ls -l '{}' ';'
-rw-rw-r-- 1 kali kali 0  9월 20일  20:28 /home/kali/foo.txt
                                                                    
```

이 예제는 일치하는 파일이 발견될 때마다 ls 명령을 실행한다. 따라서 이 표현을 다음과 같이 바꿔보자.

``` shell
┌──(kali㉿kali)-[/]
└─$ find ~ -type f -name 'foo*' -exec ls -l '{}' +       
-rw-rw-r-- 1 kali kali 0  9월 20일  20:28 /home/kali/foo.txt

```

결과는 동일하다. 다만 시스템은 ls 명령어를 한 번만 실행했을 뿐이다.

xargs 명령어를 사용해도 똑같은 결과를 얻을 수 있다. xargs 명령은 표준 입력으로부터 입력을 받아서 지정한 명령어를 위한 하나의 인자 목록으로 변환한다. 이 예제를 다음과 같이 바꿔보자.

``` shell
┌──(kali㉿kali)-[/]
└─$ find ~ -type f -name 'foo*' -print | xargs ls -l
-rw-rw-r-- 1 kali kali 0  9월 20일  20:28 /home/kali/foo.txt

```

여기서 우리는 find 명령의 출력 결과가 xargs 명령어와 연결된 것을 볼 수 있다. 결국 ls 명령어용 인자 목록을 구성한 다음, 그 명령을 실행하게 된다.

>[!tip] 저자주
>커맨드라인에는 수 많은 명령 인자가 올 수 있다. 물론 그렇다고 제한이 없는 것은 아니다. 다만 쉘이 수용할 수 있는 선에서 최대한 길게 명령어를 구성할 수 있을 것이다. ==만약 시스템이 허용하는 최대 길이를 초과하게 될 경우 xargs 명령은 최대 가능한 길이만큼 명시된 명령어에 적용하고 그런 다음 표준 입력이 끝날 때까지 반복적으로 이 작업을 진행한다.== 커맨드라인의 최대 허용 길이를 알아보려면 xargs 명령어에 --show-limits 옵션을 실행하면 된다.


>[!info] 특이한 파일명 관리하기
>유닉스형 시스템에서는 스페이스(개행까지도)를 파일명에 사용할 수 있다. 그러나 이러한 기능은 다른 프로그램의 명령 인자를 구성해주는 xargs와 같은 프로그램에는 문제가 된다. 스페이스는 하나의 구분 기호로 인식되어 스페이스로 구분된 단어를 각각 다른 명령 인자로 해석한다. 이 문제를 해결하기 위해서 find와 xargs 명령어에 null 문자를 명령 인자 구분자로 사용할 수 있다. null 문자는 ASCII 기호로 숫자 0을 의미한다(스페이스는 ASCII 코드 32다). find 명령어는 null 문자로 구분된 출력 결과를 만드는 -print0 액션을 지원하고, xargs 명령어는 --null 옵션으로 null 문자로 구분된 입력을 허용한다. 다음 예제를 살펴보자.
> *find ~ -iname '`*.jpg`' -print0 | xargs --null ls -l*
> 이러한 방법을 사용하여, 파일명에 스페이스가 있더라도 올바른 결과를 도출해낼 수 있을 것이다.

---

### 놀이터로 돌아가자


find 명령어를 실전에 적용해볼 시간이다. 우선, 수많은 파일들과 하위 디렉토리가 있는 놀이터를 만들자.

``` shell
┌──(kali㉿kali)-[~]
└─$ mkdir -p playground/dir-{00{1..9},0{10..99},100}


┌──(kali㉿kali)-[~]
└─$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}


```

커맨드라인의 능력이 경이로울 뿐이다! 우리는 단 두 줄로 놀이터에 각각 26개의 빈 파일들을 가진 100개의 하위 디렉토리를 만들었다. GUI 환경에서 이러한 작업을 해 보길!

이러한 마술 같은 작업을 위해 사용한 방법은 우리에게 친숙한 명령어 mkdir, 중간 괄호를 사용한 쉘 확장과, 새로운 명령어 [[touch]]다. mkdir과 -p 옵션(이 옵션으로 지정된 경로의 상위 디렉토리를 생성한다)을 괄호 확장과 함께 사용함으로써 우리는 100개의 디렉토리를 만들 수 있다.

- [[touch]]관련 설명




- 이 다름 [[stat]]의 내용으로 이동함.

---
### 옵션

마지막으로, 드디어 옵션까지 왔다. 옵션은 find의 검색 범위를 설정할 때 사용된다. find 표현식을 만들기 위해 다른 테스트와 액션와 함께 사용될 수 있다. [표 17-8]은 주로 사용되는 옵션이다.

- [표 17-8] find 옵션

| 옵션                 | 설명                                                                                       |
| ------------------ | ---------------------------------------------------------------------------------------- |
| -depth             | 디렉토리 자체 이전에 디렉토리의 파일에 대하여 find를 우선 실행하도록 한다. 이 옵션은 -delete 액션이 지정될 때 자동적으로 적용된다.         |
| -maxdepth *levels* | 테스트와 액션을 실행할 때, find 명령의 대상이 되는 디렉토리 **최대 탐색 깊이**를 숫자로 지정한다.                             |
| -mindepth *levels* | 테스트와 액션을 적용하기 전에, find 명령의 대상이 되는 디렉토리 최소 탐색 깊이를 숫자로 지정한다.                               |
| -mount             | 다른 파일 시스템에 마운트된 디렉토리의 탐색은 제외시킨다.                                                         |
| -noleaf            | 유닉스형 파일 시스템을 검색한다는 가정하에서 find에 최적화를 사용하지 않도록 한다. DOS/윈도우 파일시스템이나 CD-ROM을 탐색할 때 필요한 옵션이다. |
