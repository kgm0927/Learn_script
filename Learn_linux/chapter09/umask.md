
---
# 기본 권한 설정


umask 명령어는 파일이 생성될 때 주어진 ==기본 퍼미션을 제어==한다. 파일 모드 속성에서 제거할 비트 **‘마스크’** 를 표현하기 위해 8진 표기법을 사용한다.

``` shell
┌──(kali㉿kali)-[~]
└─$ ls
Desktop  Documents  Downloads  foo.txt  Music  Pictures  Public  Templates  Videos

┌──(kali㉿kali)-[~]
└─$ rm -f foo.txt         

┌──(kali㉿kali)-[~]
└─$ umask     
022

┌──(kali㉿kali)-[~]
└─$ >foo.txt           
^C

┌──(kali㉿kali)-[~]
└─$ ls -l foo.txt
-rw-r--r-- 1 kali kali 0 Mar  6 22:58 foo.txt

```


깔끔하게 시작하기 위해 foo.txt 파일을 제거했다. 그리고, 현재 마스크 값을 보기 위해 **umask** 명령어를 아무런 인자 없이 실행했다. 현재 마스크 값을 8진 표현인 0002(또 다른 일반적 기본값은 0022)로 반환했다. 끝으로 파일을 하나 생성하고 그 퍼미션을 확인했다.

소유자와 그룹 모두 읽기와 쓰기 권한을 가지고 있는 것을 볼 수 있다. 하지만 나머지 모든 사용자들은 오직 읽기 권한만을 가지고 있다. 기타 사용자는 마스크의 값 때문에 쓰기 권한을 가지고 있지 않다.

``` shell

┌──(kali㉿kali)-[~]
└─$ rm -f foo.txt

┌──(kali㉿kali)-[~]
└─$ umask 0000

┌──(kali㉿kali)-[~]
└─$ >foo.txt
^C

┌──(kali㉿kali)-[~]
└─$ ls -l foo.txt
-rw-rw-rw- 1 kali kali 0 Mar  6 23:00 foo.txt

```


마스크를 0000(사실상 끔)로 설정했을 때, 그 파일은 기타 사용자도 쓰기 가능해졌다. 이것이 어떻게 동작하는지 이해하기 위해 8진수를 다시 살펴봐야 한다.

|          |     |     |     |     |
| -------- | --- | --- | --- | --- |
| 원래 파일 모드 | --- | rw- | rw- | rw- |
| 마스크      | 000 | 000 | 000 | 010 |
| 결과       | --- | rw- | rw- | r-- |

==0들로 시작하는 것은 잠시 무시하고 마스크에 1이 나타나는 곳을 보니 속성이 제거되어 있다.== ==이 경우, 기타 사용자 쓰기 권한이 제거된 것이다.== 마스크가 하는 일이 바로 그것이다. 어디든 마스크의 2진수 값이 1을 나타내면 그 속성은 해제된다. 만약 마스크 값 0022를 살펴보면 그것이 무엇을 하는지 볼 수 있다.

|          |     |     |     |     |
| -------- | --- | --- | --- | --- |
| 원래 파일 모드 | --- | rw- | rw- | rw- |
| 마스크      | 000 | 000 | 010 | 010 |
| 결과       | --- | rw- | r-- | r-- |


다시, 2진수 값에서 1이 나타나는 곳은 해당 속성이 해제된다. 특정 값(7들로)을 가지고 어떻게 동작하는지 익숙해지자. 다 끝나면 정리를 잊어선 안된다.

``` shell
┌──(kali㉿kali)-[~/Documents]

└─$ rm -f foo.txt umask 0002
```


배포판에서 제공하는 기본값은 적당하기에 마스크를 거의 변경할 필요가 없다. 하지만 고도의 보안이 필요한 상황에서는 조절하기를 원할 것이다.



- ***부연 설명***

**특수 퍼미션**

항상 세 자리 수로 이루어진 8진법 퍼미션 마스크만 보았지만, 기술적으로는 네 자리 수로 표현하는 게 더 정확하다. 왜? 읽기, 쓰기, 실행 권한 외에 적게 사용되지만 다른 것이 또 있기 때문이다.

그 중 첫 번째가 **setuid 비트**(8진수 4000)다. 이를 실행 파일에 적용하면 실사용자(프로그램을 실제 실행 중인 사용자)에서 **프로그램 소유자 ID**로 ==유효 사용자ID==가 변경된다. 이것은 대부분 슈퍼유저가 소유한 소수 프로그램에만 주어진다. 일반 사용자가 그 프로그램을 사용하면 **setuid root**가 된다. 그 프로그램은 슈퍼유저의 유효한 특권을 가지고 실행된다. 이는 그 프로그램이 일반 사용자의 접근이 금지된 파일과 디렉토리들에 접근하게 가능하게끔 해 준다. 분명히 이러한 권한 상승 우려 때문에 setuid 프로그램의 수는 반드시 최소화해야 한다.

두 번째로 적게 사용되는 설정은 **setgid 비트**다(8진수 2000). ==setuid 비트처럼 유효 **그룹 ID**를 사용자의 실제 **그룹 ID**에서 파일 소유자의 **그룹 ID**로 변경한다.== 만약 setgid 비트가 디렉토리에 설정되어 있으면, 이 디렉토리에 새로 생성된 파일들은 디렉토리 그룹 소유권보다 파일 생성자의 그룹 소유권을 얻게 될 것이다. 이는 일반 그룹의 멤버가 파일 소유자의 그룹과 상관없이 디렉토리 내의 모든 파일에 접근이 필요한 공유 디렉토리에 유용하다.


세 번째는 **sticky 비트**(8진수 1000)다. ==이것은 고대 유닉스의 유산으로, “스왑(swap)되지 말아야 하는”실행 파일에 표시 가능하다.== 리눅스는 파일의 sticky 비트는 무시한다. 하지만 디렉토리에 적용되면 디렉토리 소유자거나 파일 소유자 또는 슈퍼유저가 아닌 이상 사용자들은 파일을 삭제하거나 이름을 변경하지 못하도록 막는다. 이는 **/tmp** 디렉토리처럼 공용 드렉토리 접근에 주로 사용된다.

이 특수 퍼미션들을 설정하기 위해 기호 표기법으로 chmod 명령을 사용하는 예제가 있다. 먼저, 프로그램에 setuid를 할당해 보자.

(나머지는 일단 넘김. 확인을 위해서는 98~99.page 확인.)