
### 우리는 이전 장에서 쉘이 어떻게 문자열과 수를 조작하는지 살펴보았다. 이런 데이터 타입들은 컴퓨터 과학에서 ==**스칼라 변수**==로 알려진, 하나의 값을 가진 변수들이다.


이 장에서는 복수 값을 지닌 **배열**이라는 또 다른 데이터 구조를 살펴볼 예정이다. 배열은 거의 프로그래밍 언어에서 지원하는 기능이다. 쉘 또한 방식이긴 하지만 역시 지원한다. 그렇다해도 프로그래밍 문제를 해결하기에 부족함이 없을 것이다.

---
# 배열이란?


배열은 하나 이상의 값을 가지고 있는 변수다. 배열은 테이블과 같은 형태로 구성된다. 스프레드시트를 예로 들어보자. 스프레드시트는 **이차원 배열**처럼 동작한다. 행과 열이 있고, 스프레드시트의 각 셀은 행렬 주소에 따라 위치한다. 배열도 이 같은 방식으로 동작한다. 배열은 원소라고 부르는 셀들을 가지고 있다. 그리고 각 원소들은 데이터를 가지고 있다. 각 배열의 원소에는 **인덱스** 혹은 **첨자**라 불리는 주소를 사용하여 접근할 수 있다.

대부분 프로그래밍 언어들이 **다차원 배열**을 지원한다. 스프레드시트는 가로, 세로의 이차원으로 이뤄진 다차원 배열의 한 예다. 많은 언어들이 임의의 차원을 가진 배열을 지원한다. 아마 가장 많이 사용되는 것은 2,3 차원 바열일 것이다.

bash에서는 제한적으로 단일 배열만 제공한다. 스프레드시트의 세로 줄 하나를 떠올리면 된다. 이런 제한도 이를 보완하기 위한 많은 애플리케이션들이 있다. 배열은 bash 버전 2에서 처음으로 지원하기 시작했다. 그러나 원조 유닉스 쉘 프로그램인 sh는 배열을 전혀 제공하지 않는다.


---

# 배열 생성

배열 변수는 다른 bash 변수들처럼 이름을 붙일 수 있고 접근 시에 자동적으로 변수가 만들어진다.

```shell
┌──(kali㉿kali)-[~]
└─$ a[1]=foo                   
                                                                
┌──(kali㉿kali)-[~]
└─$ echo ${a[1]}
foo

```

이 예제에서 배열 원소의 할당과 접근 모두를 볼 수 있다. 첫 번째 명령으로 배열의 원소 1에 값 foo가 할당한다. 두 번째 명령어는 원소 1에 저장된 값을 표시한다. 두 번째 명령에서 중괄호의 사용은 배열 원소명에서 경로명 확장이 되는 것을 막기 위해 필요하다.

배열은 또한 declare 명령어로도 생성할 수 있다.

```shell
┌──(kali㉿kali)-[~]
└─$ declare -a a   

```

이 예제에서 -a 옵션을ㄹ 사용하여 배열 a를 생성한다.

---
# 배열에 값 할당

값은 두 방식 중 하나로 할당할 수 있다. 다음 문법을 사용하여 단일 값을 할당할 수 있다.

`name[subscript]=value`

*name*은 배열의 이름이고, *subscript*는 0과 같거나 보다 큰 정수(또는 산술식)다. 배열의 첫 번째 원소의 첨자가 1이 아닌 0인 것에 주의하라. 그리고 value는 배열 원소에 할당된 문자열 또는 정수다.

다음 문법을 사용하여 복수 값을 할당할 수도 있다.

`name=( value1 value2 ... )`

*name*은 배열의 이름이고, *value1 value2 ...* 는 배열 원소 0부터 순차적으로 할당된 값들이다. 예를 들면, 요일 배열에 요일의 약어를 할당하려면 이처럼 해볼 수 있다.

```shell
┌──(kali㉿kali)-[~]
└─$ days=(Sun Mon Tue Wed Thu Fri Sat)
```

또한 각각의 값에 대하여 첨자를 사용함으로써 특정 원소에 값을 할당하는 것도 가능하다.

```shell
┌──(kali㉿kali)-[~]
└─$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)

```

---

# 배열 원소 접근

그럼 배열은 어디에 적합할까? 스프레드시트 프로그램으로 대량의 데이터 관리 작업을 수행하는 것처럼 많은 프로그래밍 작업에서 배열을 사용할 수 있다.

간단한 데이터 수집과 출력하는 예제를 한번 생각해보자. 특정 디렉토리에 있는 파일들의 수정 시간을 확인하는 스크립트를 생성할 것이다. 스크립트는 이 자료로부터 최근 수정된 파일들을 시간에 따라 보여주는 표를 출력할 것이다. 시스템이 가장 활성화될 때를 확인하려면 이러한 스크립트를 사용할 수 있다. 이 hours 스크립트는 다음 결과를 출력한다.

```shell
┌──(kali㉿kali)-[~]
└─$ ./hours .
-c Hour\tFiles\tHour\tFiles
-c ----\t-----\t----\t-----
00      8       12      0
01      8       13      2
02      9       14      1
03      7       15      0
04      1       16      0
05      2       17      0
06      0       18      3
07      1       19      3
08      1       20      8
09      6       21      13
10      2       22      5
11      0       23      3

Total files=83

```

hours 프로그램을 현재 디렉토리를 지정하여 실행한다. 24시간별로 얼마나 많은 파일들이 마지막으로 수정되었는지 표로 만들어 보여준다. 스크립트의 코드는 다음과 같다.

```shell
#!/bin/bash

# hours : script to count file by modification time

usage(){
        echo "usage : $(basename $0) directory" >&2
}

# Check that argument is a directory
if [[ ! -d $1 ]]; then
        usage
        exit 1
fi


# Initialize array
for i in {0..23}; do hours[i]=0; done

# Collect data
for i in $(stat -c %y "$1"/* | cut -c 12-13); do
        j=${i/#0}
        ((++hours[j]))
        ((++count))
done

# Display data
echo -c "Hour\tFiles\tHour\tFiles"
echo -c "----\t-----\t----\t-----"
for i in {0..11}; do
        j=$((i+12))
        printf "%02d\t%d\t%02d\t%d\n" $i ${hours[i]} $j ${hours[j]}
done
printf "\nTotal files=%d\n" $count
                                      
```

이 스크립트는 하나의 함수(usage)와 네 개의 섹션으로 나뉜 본문으로 구성한다. 첫 번째 색션은 커맨드라인 인자가 있고 그것이 디렉토리인지 검사한다. 만약 그렇지 않으면 사용법을 출력하고 종료한다.

두 번째 색션은 hours 배열을 초기화한다. 모든 원소의 값을 0으로 할당한다. 배열을 사용하기 전에 특별한 요구사항이 없지만 우리 스크립트는 빈 원소가 없는지 보장해야 할 필요가 있다. 반복문을 만드는 흥미로운 방법에 주목한다. for 명령어에 중괄호 확장 `({0..23})`을 사용하여, 순차적인 단어를 쉽게 생성할 수 있다.

그 다음은 섹션은 해당 디렉토리의 모든 파일에 대해 [[stat]] 프로그램을 실행하여 자료를 수집한다. 그 결과에 [[cut]] 명령을 사용하여 그 두 자리수의 시간 정보를 추출한다. 쉘이 00부터 09까지의 값을 8진수([표 34-1] 참조)로 해석하려 하기 때문에(결국에 실패), 루프 내부에서는 시간 필드의 맨 첫 자리 0을 제거할 필요가 있다. 다음은, 그 시간에 해당하는 배열 원소 값을 증가시킨다. 마지막으로 해당 디렉토리의 총 파일 수를 유지하기 위해 카운터(count)를 증가시킨다.

스크립트의 마지막 섹션은 배열의 내용을 표시한다. 먼저 헤더 항목들을 출력하고 나서 두 칼럼을 생성하는 루프에 진입한다. 끝으로, 파일들의 최종 기록을 출력한다.

---
# 배열 연산

흔히 사용되는 배열 연산들이 있다. 스크립팅에는 배열의 삭제, 크기 확인, 정렬 등과 같이 만흥ㄴ 응용들이 있다.

### 배열의 모든 내용 출력

첨자 `*`와 `@`는 배열의 모든 원소를 접근하는데 사용된다. 위치 매개변수와 함께함으로써 둘 중 `@` r기호가 더 유용하다. 여기 예제가 있다.

```shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ animals=("a dog" "a cat" "a fish")
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ for i in ${animals[*]}; do echo $i; done                              
a dog
a cat
a fish
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ for i in ${animals[@]}; do echo $i; done
a dog
a cat
a fish
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ for i in "${animals[*]}"; do echo $i; done
a dog a cat a fish
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ for i in "${animals[@]}"; do echo $i; done
a dog
a cat
a fish

```

animals 배열을 만들고 두 단어로 된 문자열 세 개를 할당한다. 그러고 나서 배열 내용에서 단어 분할이 이루어지는 것을 보기 위해 루프를 네번 실행한다 `${animals[*]}`와 `${animals[@]}` 표기는 인용되기 전까지 동일하게 동작한다. `*` 표기법은 배열의 내용을 포함한 한 단어를 반환하는 한편, `@` 표기법은 배열의 "실제" 내용인 세 단어를 결과로 출력한다
(하지만 실제 해 보면 a 와 dog, cat 같은 단어가 하나로 연결되어 나온다. 책에서는 1번째와 2번째의 실행 결과를 보면 두 단어가 분리되어 6 줄로 나온다).



### 배열 원소 수 확인

우리는 매개변수 확장을 사용하여 문자열 길이를 찾는 것과 거의 동일한 방식으로 배열 원소의 개수를 확인할 수 있다. 여기 예제가 있다.

```shell
┌──(kali㉿kali)-[~]
└─$ a[100]=foo                                    
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo ${#a[@]} # number of array elements    
100
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo ${#a[100]} # number of array element 100
3

```

배열을 만들고 100번 원소에 foo 문자열을 할당한다. 그 다음 배열 길이를 확인하기 위해 `@` 기호와 함께 매개변수 확장을 사용한다. 마지막으로 foo 문자열을 가진 100번 원소 길이를 확인한다. 우리가 100번 원소에 문자열 할당했지만, ==bash는 단지 배열에 하나의 원소만 있다고 알려주는 사실이 흥미롭다==(실제로는 다르다. `a[100]=foo`를 명령할 경우 이미 0에서 99까지의 배열이 전부 0으로 초기화되어 있다는 것을 확인했다. 그래서 명령어 `echo ${#a[@]}` 하면 그냥 100이 나온다. 전체 배열의 개수과 같은 것이다.). 이는 배열 내의 사용되지 않은 원소(0-99)를 빈 값으로 초기화하고 카운팅하는 다른 언어들과는 달리 다른 방식의 동작이다.

### 배열 내의 사용된 첨자 검색

bash는 배열의 첨자 할당에서 공백(gaps)을 허용한다. 종종 실제로 존재하는 원소를 확인하는 데 유용하다. 이것은 다음과 같은 형태의 매개변수 확장으로 이뤄질 수 있다.

`${!array[*]}`
`${!array[@]}`


array는 배열 변수의 이름이다. `*`와 `@` 형식을 인용하여 사용하는 다른 확장들처럼 매우 유용하며 분리된 단어로 확장된다.

```shell
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ foo=([2]=a [4]=b [6]=c)                 
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ for i in "${foo[@]}"; do echo $i; done

a

b

c
┌──(kali㉿kali)-[~/foo/playground]
└─$ for i in "${!foo[@]}"; do echo $i; done  
2
4
6 (실제로 이렇게 할 시 오류가 뜬다. 하지만 일단 이렇게 해 놓고 나중에 원인을 다시 분석하도록 하겠다.)
```


### 배열 끝에 원소 추가

배열 끝에 값을 추가하려고 하는 경우, 배열의 원소 수를 아는 것은 아무런 도움이 되지 못한다. 그 이유는 `*`와 `@` 표기법은 사용 중인 최대 배열 인덱스를 말해주지 않기 때문이다. 다행히도 쉘은 이에 대한 해법을 제공한다. `+=` 할당 연산자를 사용하여 자동적으로 배열의 끝에 값을 추가할 수 있다. 여기 배열 foo에 세 값을 할당한 뒤 세 개를 추가하는 예제가 있다.

```shell
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ foo=(a b c)                    
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ echo ${foo[@]}                               
a b c
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ foo+=(d e f)
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ echo ${foo[@]}
a b c d e f
             
```

### 배열 정렬

스프레드시트처럼, 종종 데이터 칼럼의 값들을 정렬할 필요가 있다. 쉘은 직접적으로 지원하진 않지만, 간단한 코딩으로 어렵지 않게 실행할 수 있다.

```shell
#!/bin/bash

# array-sort: Sort an array

a=(f e d c b a)
echo "Original array: ${a[@]}"
a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort))
echo "Sorted array: ${a_sorted[@]}"

```

스크립트의 실행 결과는 다음과 같다

```shell
┌──(kali㉿kali)-[~/foo/playground]
└─$ ./array-sort
Original array: f e d c b a
Sorted array: a b c d e f

```

스크립트는 원본 배열(a)의 내용을 명령 첨자 트릭으로 두 번째 배열(a_sorted)에 복사한다. 이 기법은 파이프라인을 변경하여 배열에 여러 명령어를 수행하기 위해 사용될 수 있다.


### 배열 삭제

배열을 삭제하기 위해서는 unset 명령어를 사용한다.

```shell
┌──(kali㉿kali)-[~/foo/playground]
└─$ foo=(a b c d e f)
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ echo ${foo[@]}
a b c d e f
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ unset 'foo[2]'
                                                                                                                   
┌──(kali㉿kali)-[~/foo/playground]
└─$ echo ${foo[@]}
a c d e f
          
```

이 예제에서는 배열 첨자 2인 세 번째 요소를 삭제한다. 배열 첨자는 1이 아닌 0부터 시작한다는 것을 명심해야 한다. 또한 배열 원소는 쉘의 경로명 확장을 방지하기 위해 반드시 따옴표가 사용되어야 한다. 

흥미롭게도, 배열에 빈 값 할당은 그 내용을 삭제하지 않는다.(하지만 실제로 실행을 해 본 결과 삭제되는 것을 알 수 있다. 이 부분도 다시 한번 확인해 보아야 겠다.)

```shell
┌──(kali㉿kali)-[~]
└─$ foo=(a b c d e f)
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ foo=             
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo ${foo[@]}

                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ 

```

또한 첨자의 사용 없이 배열 변수를 참조하게 되면서 배열 원소 0을 가리킨다(하지만 이 부분도 실행해본 결과 실제로 모든 내용이 삭제되고 A라는 하나의 값만 남는다. 이 부분도 다시 확인해볼 예정이다).

```shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ foo=(a b c d e f)
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo ${foo[@]}
a b c d e f
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ foo=A            
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo ${foo[@]}
A

```



---
# 마무리 노트

bash의 [[man]] 페이지를 array로 검색하면 배열 변수를 사용할 수 있는 많은 항목들을 발견할 수 있을 것이다. 대다수가 잘 알려져 있지 않지만, 가끔 특수한 상황에서 유용하게 사용될 수 있다. 사실, 쉘 프로그래밍에서 배열 기능 전체가 잘 활용되지는 않는다. 전통적인 유닉스 쉘 프로그램들(sh와 같은)은 배열에 대한 지원이 부족하기 때문이다. 이는 참 불운한 것이다. 배열은 다른 프로그래밍 언어에서는 광범위하게 사용되고 다양한 프로그래밍 문제를 해결하기 위해 강력한 도구를 제공하기 때문이다. 

배열과 루프는 태생적으로 관련이 있고 주로 함께 사용한다. 반복문의 형식은 특히 배열 첨자를 계산하기에 알맞다.


```shell
for (( expr1; expr2; exp3 ))
```