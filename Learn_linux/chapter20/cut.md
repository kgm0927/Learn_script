
==cut 프로그램은 행에서 텍스트 일부를 추출하고 그 부분을 표준 출력으로 보낸다.== 복수의 파일 인자나 표준 입력으로부터 입력을 허용한다. 행의 추출할 영역을 지정하는 것이 약간 어색하긴 하다. 이는 [표 20-3]의 옵션들을 사용하여 지정한다.

- [표 20-3] cut 선택 옵션


| 옵션                | 설명                                                                    |
| ----------------- | --------------------------------------------------------------------- |
| `-c` *char_list*  | *char_list*에 정의된 영역을 추출한다. 이 목록은 하나 이상의 콤마로 구분된 숫자 범위다.               |
| `-f` *field_list* | *field_list*에 정의된 하나 이상의 필드를 추출한다. 이 목록은 하나 이상의 필드거나 콤마로 구분된 필드 범위이다. |
| `-d` *delim_char* | `-f`를 지정했을 때, delim_char를 필드 구분자로 사용한다. 기본적으로 필드들은 하나 탭문자로 구분되어야 한다.  |
| `-\|-complement`  | -c와 (또는) -f로 명시된 영역을 제외한 모든 부분을 추출한다.                                 |

우리가 볼 수 있듯이, cut이 텍스트를 추출하는 방법은 약간 융통성이 없다. ==cut은 사용자가 직접 입력한 텍스트보다 다른 프로그램이 생성한 파일의 텍스트를 추출하는 데 적합하다.== 이제 distros.txt 파일을 살펴볼 것이다. 이 파일은 cut의 예제로 사용하기에 충분히 좋은 견본이다. ==cat와 **-A** 옵션을 구현하면, 탭 구분 필드의 요구 조건을 만족하는지 볼 수 있다.==

```shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ cat -A distros.txt
SUSE^I10.2^I12/07/2006$
Fedora^I10^I11/25/2008$
SUSE^I11.0^I06/19/2008$
Ubuntu^I8.04^I04/24/2008$
Fedora^I8^I11/08/2007$
SUSE^I10.3^I10/04/2007$
Ubuntu^I6.10^I10/26/2006$
Fedora^I7^I05/31/2007$
Ubuntu^I7.10^I10/18/2007$
Ubuntu^I7.04^I04/19/2007$
SUSE^I10.1^I05/11/2007$
Fedora^I6^I10/24/2006$
Fedora^I9^I05/13/2008$
Ubuntu^I6.06^I06/01/2006$
Ubuntu^I8.10^I10/30/2008$
Fedora^I5^I03/20/2006$
                         
```

문자 사이에 공백 없이 탭 문자 하나만 제대로 들어간 것 같다. 이 파일은 스페이스가 아닌 탭을 사용했기에 **-f** 옵션을 사용하여 필드를 추출할 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ cut -f 3 distros.txt
12/07/2006
11/25/2008
06/19/2008
04/24/2008
11/08/2007
10/04/2007
10/26/2006
05/31/2007
10/18/2007
04/19/2007
05/11/2007
10/24/2006
05/13/2008
06/01/2006
10/30/2008
03/20/2006
             
```

==distros 파일은 탭으로 구분되었기 때문에 cut을 사용하여 문자가 아닌 필드를 추출하는 데 적합하다. 파일이 탭으로 구분되면, 각 행이 동일한 길이의 문자들이 있지 않을 것이다.== 이는 행 내의 문자 위치를 계산하기 어렵게 하거나 불가능하게 만든다. 따라서 문자보다 필드를 구분하는 데 적절하다. 하지만 앞의 예제는 다행이 동일한 길이의 자료를 가진 필드를 추출했다. 그래서 각 행으로부터 연도를 가져오기 위해 어떻게 문자를 추출하는지 볼 수 있다.

``` shell

┌──(kali㉿kali)-[~]
└─$ cut -f 3 distros.txt | cut -c 7-10
2006
2008
2008
2008
2007
2007
2006
2007
2007
2007
2007
2006
2008
2006
2008
2006

```

목록에 cut을 두 번 실행하여 7부터 10번까지 연도에 상응하는 문자를 추출할 수 있다. 7-10 표기법은 범위를 지정하는 예다. cut의 man 페이지는 어떻게 범위를 지정하는지에 대한 자세한 사항을 포함하고 있다.

필드를 가져올 때 문자가 아닌 다른 필드 구분자를 지정하는 것도 가능하다. 이제 `/etc/passwd` 파일에서 첫 번째 필드를 추출할 것이다.

``` shell
┌──(kali㉿kali)-[~]
└─$ cut -d ':' -f 1  /etc/passwd | head
root
daemon
bin
sys
sync
games
man
lp
mail
news
        
```

-d 옵션을 사용하여 콜론 문자를 구분자로 지정할 수 있다.


>[!tip] 탭 확장
>distros.txt 파일은 cut을 사용하여 필드를 추출하기 위해 이상적으로 포맷되었다. 하지만 필드가 아닌 문자로 구분된 파일을 조작하기 위해 cut을 사용한다면 어떻게 될까? 이는 파일에 탭 문자 대신에 그에 상응하는 수의 스페이스가 필요하다. 다행히도 GNU coreutils 패키지는 그러한 툴을 가지고 있다. expand라는 이름의 그 프로그램은 표준 입력 또는 하나 이상의 파일 인자를 받아들여 처리한다. 그리고 그 프로그램은 수정된 텍스트를 표준 출력을 보낸다.
>expand로 distros.txt 파일을 처리하면, 파일에서 문자열 범위를 추출하기 위해 `cut -c`를 사용할 수 있다. 예를 들면, 배포판 목록에서 출시 연도를 추출하기 위해, 파일을 확장하고 cut으로 23번 위치부터 행의 끝까지 모든 문자를 추출하기 위해 다음과 같이 명령어를 사용할 수 있다.
>`┌──(kali㉿kali)-[~] $expand distros.txt | cut -c 23-
`
>또한 coreutiles는 스페이스를 탭으로 치환하는 unexpand 프로그램을 제공한다.




`

