### 텍스트 필터링과 변환용 스트림 편집기


sed란 이름은 stream editor의 약자다. 텍스트 스트림과 명시된 파일 집합과 표준 입력에서도 텍스트 편집을 수행한다. sed는 강력하고 다소 복잡한 프로그램(이에 대한 책이 있다)이다. 그래서 여기서는 그 전부를 다루지는 않을 것이다.

일반적으로 sed가 동작하는 방식은 단일 편집 명령어나 복수의 명령어를 포함한 스크립트 파일이 주어진다. 그러고 나서 이 명령어들은 텍스트 스트림의 각 행 위에서 수행된다. 여기 sed의 매우 간단한 예제가 실행중이다.

``` shell

┌──(kali㉿kali)-[~]
└─$ echo "front" | sed 's/front/back/'
back

```

이 예제에서는 echo를 사용하여 한 단어 스트림을 생성하고 그것을 sed로 송신한다. sed는 그 스트림의 텍스트에 `s/front/back` 명령을 수행하고 결과로 back을 출력한다. 또한 이것은 [[chapter12 VI 맛보기|vi]]에서 치환(검색과 대체) 명령과 비슷한 명령어로 인식할 수 있다.

sed의 명령은 한 글자로 시작한다. 이 예제에서 치환 명령은 글자 **s**로 표현되고 이어서 슬래시 문자로 구분된 검색할 문자열과 대체할 문자열이 따라온다. 구분 문자의 선택은 임의로 정할 수 있다. 지금까지의 관례에 따라 주로 슬래시 문자가  사용된다. ==하지만 sed는 구분자로 명령어에 바로 따라오는 어떤 문자라도 허용할 것이다.== 이러한 방식으로 동일한 명령을 수행할 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ echo "front" | sed 's_front_back_'                                 
back
             

```

밑줄 표시가  명령어 뒤에 바로 사용되면 그것은 구분자가 된다. 구분자를 설정하는 기능은 더 읽기 쉽게 만들어준다.

sed의 다수 명령어들은 편집될 입력 스트림의 행 번호를 지정한 **주소**를 앞세울 것이다. 만약 그 주소를 생략하면, 편집 명령은 입력 스트림의 모든 행에 실행된다. 주소의 가장 간단한 형태는 행 번호다. 다음과 같이 예제에 추가할 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ echo "front" | sed '1s/front/back/'
back

```

명령어 주소 1을 추가하여 입력 스트림의 첫 번째 행에만 치환을 수행하게끔 한다. 물론 다른 숫자를 지정할 수도 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ echo "front" | sed '2s/front/back/'
front

```

입력 스트림에는 2번 행이 없기 때문에 편집이 수행되지 않는 것을 보게 된다.

주소는 다양한 방식으로 표현된다. [표 20-7]은 주소 표현 방식을 나열한 것이다.


- [표 20-7] sed 주소 표기법

| 주소             | 설명                                                                                                                                        |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| *n*            | *n*은 양수인 행 번호                                                                                                                             |
| $              | 마지막 행                                                                                                                                     |
| */regexp/*     | POSIX 기본 정규 표현식과 일치하는 행들. 정규 표현식은 슬래시 문자로 구분된다는 것을 명심해라. 부가적으로 정규 표현식은 *\cregexpc*를 표현식과 함께 명시하면 다른 문자로 구분될 수 있다. 여기서 c는 구분자로 사용할 대체 문자다. |
| *addr1, addr2* | *addr1*부터 *addr2*까지 범위의 행들, 주소는 단일 주소 형태의 어느 것이든 상관없다.                                                                                    |
| *first~ step*  | *first* 번호에 표현된 것과 일치하는 행과 그 다음 *step* 간격마다 모든 행. 예를 들면 1~2는 모든 홀수 행을  가리키고, 5~5는 5번 행과 그 이후 매 5번째 행을 가리킨다.                               |
| *addr1, +n*    | *addr1*과 일치하는 행과 다음 n개의 행들.                                                                                                               |
| *addr!*        | *addr*을 제외한 모든 행. *addr*에는 위 형태 중 어느 것이든 올 수 있다.                                                                                          |


이 장 초반부의 distros.txt 파일을 사용하여 각기 다른 종류의 주소들을 시현할 것이다. 먼저 행 번호 범위다.

``` shell
┌──(kali㉿kali)-[~]
└─$ sed -n '1, 5p' distros.txt                                         
SUSE    10.2    12/07/2006
Fedora  10      11/25/2008
SUSE    11.0    06/19/2008
Ubuntu  8.04    04/24/2008
Fedora  8       11/08/2007

```

이 예제에서는 지정된 범위 내의 행들을 출력한다. 1번 행부터 시작하여 계속하여 5번 행까지 나타낸다. 이를 위해, 단순히 일치된 행을 출력하는 p 명령을 사용한다. 하지만 이를 적용하기 위해서는 반드시 **-n**(수동 출력 옵션)을 포함해야 한다. 왜냐하면 **sed**는 기본적으로 모든 행을 출력하기 때문이다.

다음은 정규 표현식을 사용한 것이다.

```shell
┌──(kali㉿kali)-[~]
└─$ sed -n '/SUSE/p' distros.txt
SUSE    10.2    12/07/2006
SUSE    11.0    06/19/2008
SUSE    10.3    10/04/2007
SUSE    10.1    05/11/2007


```

슬래시로 구분된 정규 표현식 **/SUSE/** 를 사용하여 grep과 같은 방식으로 그 내용을 포함한 행들을 분리할 수 있다.

마지막으로, 감탄사 부호(!)를 주소에 추가하여 부정문을 시도할 것이다.

```shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ sed -n '/SUSE/!p' distros.txt
Fedora  10      11/25/2008
Ubuntu  8.04    04/24/2008
Fedora  8       11/08/2007
Ubuntu  6.10    10/26/2006
Fedora  7       05/31/2007
Ubuntu  7.10    10/18/2007
Ubuntu  7.04    04/19/2007
Fedora  6       10/24/2006
Fedora  9       05/13/2008
Ubuntu  6.06    06/01/2006
Ubuntu  8.10    10/30/2008
Fedora  5       03/20/2006

```

예상한 결과가 나타난다. 파일 내에서 정규 표현식과 일치된 것을 제외한 모든 행을 출력한다.

지금까지 우리는 sed 편집 명령어 s와p, 이 두가지를 살펴보았다. [표 20-8]은 기본 편집 명령어의 좀 더 완전한 목록이다.


- [표 20-8] sed 기본 편집 명령어


| 명령어                    | 설명                                                                                                                                                                                                                                                                                        |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| =                      | 현재 행 번호를 출력한다.                                                                                                                                                                                                                                                                            |
| a                      | 현재 행 뒤에 텍스트를 추가한다.                                                                                                                                                                                                                                                                        |
| b                      | 현재 행을 삭제한다.                                                                                                                                                                                                                                                                               |
| i                      | 현재 행 앞에 텍스트를 삽입한다.                                                                                                                                                                                                                                                                        |
| p                      | 현재 행을 출력한다. sed는 기본적으로 모든 행을 출력하고, 파일 내에서 지정된 주소와 일치하는 행들만 편집한다. 기본 동작은 -n 옵션을 명시하며 무시할 수 있다.                                                                                                                                                                                             |
| q                      | sed는 더 이상 처리할 행이 없으면 종료한다. 만약 -n 옵션이 명시되어 있지 않으며, 현재 행을 출력한다.                                                                                                                                                                                                                             |
| Q                      | sed는 더 이상 처리할 행이 없으면 종료한다.                                                                                                                                                                                                                                                                |
| *s/regexp/replacement* | *regexp*가 발견될 때마다 *replacement*의 내용으로 치환한다. *replacement*는 *regexp*와 일치하는 텍스트와 동등한 특수 문자 **&** 를 포함할 수 있다. 게다가 *replacement*는 *regexp*의 부 표현식과 상응하는 내용들을 가리키는 \1부터 \9까지의 문자열을 포함할 수도 있다. 이에 대한 좀 더 자세한 사항은 뒷부분을 참조하라. *replacement*에 뒤따른 슬래시 이후는, s 명령의 동작을 수정하기 위해 명시될 수 있는 **옵션 플래그**다. |
| *y/set1/set2*          | *set1* 문자들을 *set2*의 상응하는 문자들로 변환한다. sed는 [[tr]]과 달리 동일한 길이의 집합들이 필요하다는 것을 유념해라.                                                                                                                                                                                                           |

s 명령어는 단연코 가장 많이 사용되는 편집 명령어이다. 우리는 distros.tx 파일을 편집하여 그 능력의 일부를 보여줄 것이다. 이전에 distros.txt의 날짜 필드가 얼마나 "컴퓨터 친화적인" 포맷이 아닌지에 대해 논의했다. 그 날짜는 `MM/DD/YYYY`로 포맷되긴 했지만, 만약 `YYYY-MM-DD`의 포맷(정렬하기 쉬운)이라면 더 나을 것이다. 그 파일을 수작업으로 수정하면 많은 시간과 오류가 발생할 수 있다.

``` shell

┌──(kali㉿kali)-[~]
└─$ sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
SUSE    10.2    2006-12-07
Fedora  10      2008-11-25
SUSE    11.0    2008-06-19
Ubuntu  8.04    2008-04-24
Fedora  8       2007-11-08
SUSE    10.3    2007-10-04
Ubuntu  6.10    2006-10-26
Fedora  7       2007-05-31
Ubuntu  7.10    2007-10-18
Ubuntu  7.04    2007-04-19
SUSE    10.1    2007-05-11
Fedora  6       2006-10-24
Fedora  9       2008-05-13
Ubuntu  6.06    2006-06-01
Ubuntu  8.10    2008-10-30
Fedora  5       2006-03-20

```

대단하다! 이상한 명령어처럼 보이긴 하지만 잘 작동한다. 우리는 단번에 파일 내의 날짜 포맷을 변경했다. 또한 왜 정규 표현식이 종종 농담으로 "쓰기 전용" 매체라 불리는지에 대한 완벽한 예제다. 우리는 그것을 작성할 수는 있지만 때때로 읽을 수는 없다. 우리가 이 명령어에 놀라 달아나고픈 유혹에 빠지기 전에 어떻게 생성됐는지 살펴보자. 먼저 이 명령어의 기본 구조를 알아보자.

`sed 's/regexp/replacement/' distros.txt`

다음 과정은 날짜를 분리할 정규 표현식을 이해하는 것이다. 그것은 `MM/DD/YYYY` 포맷이고 행의 끝을 나타나기 때문에, 다음과 같이 표현식을 사용할 수 있다.

`[0-9]{2}/[0-9]{2}/[0-9]{4}$ `

두 자리 수, 슬래시, 두 자리 수, 슬래시, 네 자리 수와 행 끝 문자열과 일치한다. 그래서 regexp는 살펴보았지만 replacement는 어떠한가? 이를 다루기 위해서는 BRE를 사용하는 일부 프로그램에서 나타나는 새로운 정규 표현식 기능을 소개해야 한다. 이 기능은 **후방 참조**라 불리고 다음과 같이 동작한다. replacement에 `\n` 문자열이 포함되어 있으면 그 문자열은 앞선 정규 표현식에 해당하는 서브 포현식을 가리킨다. 여기서 n는 1부터 9까지의 숫자다. 서브 표현식을 만들려면 단순히 다음과 같이 괄호로 둘러싸면 된다.

`([0-9]{2})/([0-9]{2})/([0-9]{4})$ `

이제 이 세개의 서브 표현식이 생겼다. 첫째는 월을 포함하고, 둘째는 해당 월의 일자를 포함하고, 마지막으로 셋째는 연도를 포함한다. 이제 다음처럼 replacement를 만들 수 있다.


`\3-\1-\2`

년, 대시, 월, 대시, 일 순서다.

이제, 이와 같은 우리의 명령어를 살펴보자.

``` shell

sed 's/([0-9]{2}/)/([0-9]{2})/([0-9]{4})$/\3-\1-\2/' distros.txt

```

두 가지 문제가 있다. 첫째는 sed가 s 명령을 해석하려 할 때 정규 표현식의 슬래시를 혼동할 수 있다는 것이다. 둘째는, sed 때문에 기본 정규식만 허용이 가능하다는 것이다. 정규 표현식 문자들이 메타 문자가 아닌 **상수 문자로 처리**될 것이다. ==이 두 문제를 해결하려면 문제가 되는 문자들을 처리하기 위해 백스래시의 사용이 필요하다.==

```
sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
```

그러면 이제 제대로 된다.

s 명령어의 또 다른 기능은 대체 문자에 적용되는 추가적인 플래그 사용이다. 이 중 가장 중요한 것은 g 플래그이다. 이 플래그는 sed에 치환 기능을 하나의 문자(기본 설정)가 아닌 행 전체에 적용하도록 투시한다.

여기 예제가 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ echo "aaabbbccc" | sed 's/b/B/'    
aaaBbbccc
               
```

우리는 b 문자 중 오직 하나만이 교체가 되고 나머지 문자들은 변경되지 않는 것을 보게 된다. 여기에 g 플래그를 추가하면 문자들을 변경할 수 있다.

``` shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "aaabbbccc" | sed 's/b/B/g'
aaaBBBccc
              
```

지금까지 우리는 커맨드라인을 통해 sed 단일 명령어만을 보았다. `-f` 옵션을 사용하면 스크립트 파일을 통해 좀 더 복잡한 명령도 가능하다. 이를 보여주기 위해, ==sed로 distros.txt 파일을 사용하여 보고서를 만들게 될 것이다.== ==보고서 상단에는 제목을, 수정된 날짜와 대문자로 변환된 배포판 이름을 가지게 될 것이다.== 이를 위해, 스크립트 작성이 필요하다. 따라서 텍스프 편집기를 실행하고 다음을 입력할 것이다.

```shell                             
#sed script to produce Linux distributions report


1 i\
\
Linux Distributions Report\

s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/

```


sed 스크립트를 distros.txt로 저장하고, 이처럼 실행할 것이다.
``` shell
┌──(kali㉿kali)-[~]
└─$ sed -f distros.sed distros.txt                                               

Linux Distributions Report

SUSE    10.2    2006-12-07
FEDORA  10      2008-11-25
SUSE    11.0    2008-06-19
UBUNTU  8.04    2008-04-24
FEDORA  8       2007-11-08
SUSE    10.3    2007-10-04
UBUNTU  6.10    2006-10-26
FEDORA  7       2007-05-31
UBUNTU  7.10    2007-10-18
UBUNTU  7.04    2007-04-19
SUSE    10.1    2007-05-11
FEDORA  6       2006-10-24
FEDORA  9       2008-05-13
UBUNTU  6.06    2006-06-01
UBUNTU  8.10    2008-10-30
FEDORA  5       2006-03-20

```

보는 것처럼, 이 스크립트는 원하는 결과를 만들어준다. 하지만 어떻게 그렇게 되는 걸까? 스크립트를 다시 한번 살펴보자. 이번에는 cat을 사용하여 행 번호를 함께 출력하자

```shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ cat -n distros.sed
     1  #sed script to produce Linux distributions report
     2
     3
     4  1 i\
     5  \
     6  Linux Distributions Report\
     7
     8  s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
     9  y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
                                                                      
```

1번 행은 스크립트의 **주석**이다. 리눅스 상의 많은 설정 파일들과 프로그래밍 언어들처럼 **#** 문자로 시작해서 사람이 읽을 수 있는 텍스트가 따라온다. 주석은 스크립트 어디든 위치할 수 있고(명령어 내에는 제외하고) 그 스크립트를 확인하거나 유지할 필요가 있는 사람에게 유용할 수 있다.

2번 행은 공백 줄이다. 주석처럼 공백 줄들은 가독성을 높이기 위해 추가될 수 있다.

많은 sed 명령어들은 행 주소를 지원한다. 이들은 입력 행에 따라 동작하기 위해 명시된다. 행 주소는 단일 행 번호, 행 범위, 입력을 마지막 행을 가리키는 **$** 과 같이 특수한 행 번호들로 표현될 수 있다.

3번부터 6번 행은 입력의 첫 행인 주소 1에 삽입될 텍스트를 포함하고 있다. i 명령어 뒤에는 확장 캐리지 리턴(**행 지속 문자**: line-continuation character)을 생성하기 위해 백슬래시-캐리지 리턴 문자열이 붙는다. 이 문자열은 행 끝에 도달한 인터프리터(여기서는 sed)가 표식 없이 텍스트 스트림에 캐리지 리턴의 내장을 허용하는 쉘 스크립트를 포함한 많은 상황하에서 사용될 수 있다. **i** 명령어와 명령어 **a**(텍스트 추가)와 **c**(텍스트 교체)는 다수의 행을 허용한다. ==마지막 행을 제외하고 행 지속 문자로 끝나는 각 행을 공급한다.== 스크립트의 6번째 행은 실제로 삽입된 텍스트의 마지막이고, 행 지속 문자가 아닌 i 명령어의 끝 표시인 일반 캐리지 리턴으로 끝난다.


>[!tip] 저자주
>행 지속 문자는 캐리지 리턴이 바로 따라오는 **백슬래시**로 형성된다. 그 사이에 공백은 허용되지 않는다.


8번 행은 치환 명령어다. 주소를 선행하지 않기 때문에, 입력 스트림의 모든 행이 종속된다.

9번 행은 소문자를 대문자로 변환한다. sed의 y 명령어는 tr과 달리 문자 범위(예를 들어, `[a-z]`)와 POSIX 문자 클래스도 지원하지 않는다는 것을 명심해라. 또 다시, y 명령어는 주소를 선행하지 않기 때문에 모든 행에 적용된다.


>[!info] SED 부류를 좋아하는 사람들
>sed는 텍스트에 꽤 복잡한 작업을 수행할 수 있는 매우 유능한 프로그램이다. 긴 스크립트보다 한 줄짜리 작업같이 간단한 작업을 위해 주로 사용된다. 많은 사용자들이 광범위한 작업을 위해 다른 도구들을 선호한다. 그 중 가장 인기있는 것은 **awk**와 **perl**(펄)이다. 이것들은 여기서 다룬 프로그램들처럼 단순한 툴을 넘어서 완전한 프로그래밍 언어의 영역으로 확대된다. 특히 perl은 많은 시스템 관리 작업들을 위한 쉘 스크립트들에 자주 사용된다. 게다가 웹 개발에 가장 인기 있는 매체다. awk는 약간 더 전문적이다. 두드러진 강점은 표로 구성된 자료를 조작하는 능력이다. awk 프로그램은 행 단위로 텍스트 파일을 처리하는 면에서 sed와 닮았다. 주소에 행동이 따라오는 sed의 방식과 유사한 체계를 사용한다. awk와 perl 둘다 이 책의 범위를 벗어나긴 하지만, 리눅스 커맨드라인 사용자에 매우 훌륭한 도구들이다.

