

##### 이 장부터는, 텍스트를 조작하는 툴을 살펴볼 것이다. 이미 본 것처럼, 텍스트는 리눅스와 같은 유닉스형 시스템들에서 매우 중요한 역할을 하고 있다. 하지만 이러한 툴들이 제공하는 모든 기능을 제대로 인식하기 전에, 우리는 툴과 함께 정교하게 사용되는 기술을 알아볼 수 있다. 그것이 정규 표현식이다.


우리는 커맨드라인이 제공하는 많은 기능과 편의들을 살펴보았고, 쉘 확장과 인용, 키보드 단축, 명령어 히스토리인 vi는 말할 나위 없이 정말로 신기한 쉘 기능과 명령어들도 접했다. 정규 표현식은 이 "전통"을 잇는, 그들 중 가장 (틀림없이) 신기한 기능일 것이다. 하지만 그것을 배우는 것은 시간이 아깝기 때문에 추천하지 않는다. 오히려 그 정반대다. 비록 그 모든 가치가 즉각적으로 나타나지는 않지만, 올바르게 이해하는 것은 놀라운 위업을 달성할 수 있게 할 수 있다.

---
# 정규 표현식이란?

간단히 말해서, **정규 표현식**은 텍스트에서 패턴을 인식하는 심볼 표기법이다. 어떤 면에서는파일과 경로명 매칭에 사용하는 쉘의 와일드카드 방식과 닮았지만 보다 웅장한 규모다. 정규 표현식은 텍스트 조작 문제의 해결을 용이하게 하기 위해 많은 커맨드라인 툴들과 대부분의 프로그래밍 언어에 제공된다. 하지만, 더 혼동스러운 것은 모든 정규 표현식이 같이 않다는 것이다. 도구들마다 조금씩 다르고 프로그래밍 언어들마다 다르다. 우리는 좀 더 크고 풍부한 표기 집합을 사용하는 프로그래밍 언어들(특히 Perl)과 대조적으로, POSIX 표준(커맨드라인 툴의 대부분이 다루는)의 정규 표현식으로 한정하여 이야기할 것이다.


---
# grep - 텍스트를 통한 검색

- [[grep#텍스트를 통한 검색|grep]]

---
# 메타문자와 리터럴

분명히 보이진 않겠지만, **grep** 검색은 간단하게 나마 내내 정규 표현식을 사용했다. 정규 표현식 bzip은 b,z,i,p 문자순으로 그 사이에 아무런 문자 없이 적어도 네 문자를 포함하는 파일 행과 일치함을 보인다. bzip 문자열의 문자들은 모두 그 자체로 일치되는 **상수 문자**(literal character)다. 정규 표현식은 리터럴 외에도 메타문자로 포함할 수 있다. 그것은 더 복잡한 매치 식을 지정하는데 사용된다. 정규 표현 메타문자들은 다음으로 구성된다.


` ^ $ . [ ] { } - ? + ( ) | \`

비록 백슬래시 문자는 **메타시퀀스**를 생성하는 경우에 사용되긴 하지만 나머지 모든 문자들은 리터럴로 간주된다. ==메타문자들도 메타문자로 인터프리트되는 대신에 확장되거나 리터럴로 처리될 수 있다.==

>[!important] 저자주
>이미 본 것처럼, 다수의 정규 표현 메타문자들 또한 쉘에서 확장될 대 의미가 있는 문자다. 커맨드라인에서 메타문자를 포함한 정규 표현식을 전달할 때, 쉘에서 확장을 시도하지 않은 메타문자들을 따옴표로 감싸는 것이 필요하다.



---
# 모든 문자

우리가 살펴볼 첫 번째 메타문자는 어떤 문자든지 일차하는 도트(.) 문자다. 만약 그 문자를 정규 표현식에 포함하면, 그 문자 위치의 어떤 문자든 일치할 것이다. 여기 예제가 있다.


```shell

┌──(kali㉿kali)-[~]
└─$ grep -h '.zip' dirlist*.txt                 
bunzip2
bzip2
bzip2recover
funzip
gpg-zip
gunzip
gzip
p7zip
preunzip
prezip
prezip-bin
streamzip
unzip
unzipsfx
bunzip2
bzip2
bzip2recover
funzip
gpg-zip
gunzip
gzip
p7zip
preunzip
prezip
prezip-bin
streamzip
unzip
unzipsfx

```

우리는 정규 표현식 `.zip`과 일치하는 파일 행들을 검색했다. ==결과에 관한 두 가지 흥미로운 것이 있다. 여러분은 zip 프로그램을 찾지 못했다는 것을 알아챘을 것이다.== ==그 이유는 앞선 정규 표현식의 도트 메타문자로 인해 최소 네 문자의 일치가 필요하기 때문이다.== zip이라는 이름은 세 문자이기에 일치할 수 없다. 만약, 목록 중 어떤 파일이 파일 확장자로 .zip을 포함하고 있다면, 파일 확장자의 문자도 "해당 문자"로 처리되기 때문이다.


---
# 앵커(Anchors)

정규 표현식에서 캐럿(^)과 달러 기호(`$`) 문자는 앵커(anchors)로 처리된다. 이는 해당 정규 표현식이 행의 시작(^)이나 행의 끝(`$`)에서 발견되는 경우에만 일치하게 된다는 것을 의미한다.

``` shell

┌──(kali㉿kali)-[~]
└─$ grep -h '^zip' dirlist*.txt
zip
zipcloak
zipdetails
zipgrep
zipinfo
zipnote
zipsplit
zip2john
zip
zipcloak
zipdetails
zipgrep
zipinfo
zipnote
zipsplit
zip2john
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ grep -h 'zip$' dirlist*.txt
funzip
gpg-zip
gunzip
gzip
p7zip
preunzip
prezip
streamzip
unzip
zip
funzip
gpg-zip
gunzip
gzip
p7zip
preunzip
prezip
streamzip
unzip
zip
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ grep -h '^zip$' dirlist*.txt
zip
zip

```

우리는 zip 문자열이 행의 시작, 행의 끝, 그리고 행의 시작과 끝 모두에 나타나는 경우(즉, 행 그 자체)에 해당하는 파일 목록을 찾았다. 정규 표현식`^$`(그 사이에 아무것도 없는)는 공백 줄과 일치하게 된다는 것을 명심해야 한다.


>[!TIP]
>리눅스 시스템에 사전이 포함되어 있다는 것을 아는가? 그렇다. /usr/share/dict 디렉토리를 살펴보면 하나 또는 여러 개를 발견하게 될 것이다. 거기에 위치한 사전 파일들은 단지 단어의 긴 목록들이다. 행마다 하나씩 알파벳 순서로 정렬되어 있다. 필자의 시스템에는 98,500여 개의 단어를 가진 **words** 파일이 있다. 십자말 풀이 게임의 답을 찾기 위해 이처럼 해 볼 수 있다.
>``` shell
>	┌──(kali㉿kali)-[~]
└─$ grep -i '^..j.r$' /usr/share/dict/words
Major
major
>```
>정규 표현식을 사용하여 사전 파일에서 j가 세 번째이고 r이 마지막 위치인 다섯 글자로 되 모든 단어를 찾을 수 있다.


---

# 괄호 표현식과 문자 클래스

정규 표현식에서 정해진 위치의 문자와 일치하는 것뿐만 아니라 **괄호 표현식**을 사용하여 문자 집합의 한 문자와 일치하는지 확인할 수 있다. 괄호 표현식으로 비교할 문자(메타문자로 해석되는 것 이외의 문자들을 포함) 집합을 지정할 수 있다. 이 예제에서 두 문자 집합을 사용하여 bzip 또는 grzip 문자열을 포함한 모든 행을 출력한다.

``` shell
┌──(kali㉿kali)-[~]
└─$ grep -h '[bg]zip' dirlist*.txt         
bzip2
bzip2recover
gzip
bzip2
bzip2recover
gzip
       
```

==집합은 여러 문자들을 포함할 수 있고 괄호 안에 놓인 메타문자들은 본래의 특수한 의미를 잃어버린다.== 하지만 메타문자는 괄호 표현식에서 다른 의미로 사용되는 경우가 둘 있다. 첫째는 부정을 나타내는 캐럿(^)이고, 둘째는 대시(-)로 문자 범위를 나타낸다.


### 부정

만약 괄호 표현식의 첫 번째 문자가 캐럿이면, 나머지 문자들은 해당 문자 위치에 존재하지 않는 문자들의 집합으로 설정된다. 이전 예제를 수정해서 확인해보자.

``` shell
┌──(kali㉿kali)-[~]
└─$ grep -h '[^bg]zip' dirlist*.txt
bunzip2
funzip
gpg-zip
gunzip
p7zip
preunzip
prezip
prezip-bin
streamzip
unzip
unzipsfx
bunzip2
funzip
gpg-zip
gunzip
p7zip
preunzip
prezip
prezip-bin
streamzip
unzip
unzipsfx

```

부정의 활성으로 zip 문자열 바로 앞에 b나 g를 제외한 문자를 가진 파일 목록을 얻는다. zip 파일은 여기에 해당되지 않는다는 것을 알게 될 것이다. 부정 문자 집합은 여전히 해당 위치에 문자를 요구한다. 하지만 그 문자는 반드시 부정 집합을 멤버가 아니어야 한다.

캐럿 문자는 괄호 표현식의 첫 번째 문자인 경우에만 부정을 행한다. 반면, 그것은 자신의 특수한 의미를 잃어버리고 집합을 평범한 문자가 된다.


### 전통적인 문자 범위

목록에서 대문자로 시작하는 이름을 가진 모든 파일을 찾는 정규 표현식을 생성하려고 한다면, 이처럼 하면 된다.

``` shell

┌──(kali㉿kali)-[~]
└─$ grep -h '^[ABCDEFGHIJKLMNOPQRSTUVWXZY]' dirlist*.txt
DPAPImk2john
FileCheck-16
FileCheck-17
GET
GenPat
HEAD
JxrDecApp
JxrEncApp
POST
Thunar
UnicodeNameMappingGenerator-16
UnicodeNameMappingGenerator-17
VBoxClient
X
...

```

단지 26개의 대문자를 괄호 표현식에 넣은 것이다. 하지만 전부 타이핑하려면 상당한 문제가 될 것이다. 그래서 다른 방식이 필요하다.

``` shell
┌──(kali㉿kali)-[~]
└─$ grep -h '^[A-Z]' dirlist*.txt
DPAPImk2john
FileCheck-16
FileCheck-17
GET
GenPat
HEAD
JxrDecApp
JxrEncApp
POST
Thunar
UnicodeNameMappingGenerator-16
UnicodeNameMappingGenerator-17
VBoxClient
X
...
```

3-문자 범위를 사용하여, 26자를 줄일 수 있다. 문자 범위는 복수 범위를 포함한 방식으로 표현될 수 있다. 다음은 무자와 숫자로 시작하는 모든 파일명과 비교하는 표현식이다.

```shell
┌──(kali㉿kali)-[~]
└─$ grep -h '^[A-Za-z0-9]' dirlist*.txt
1password2john
2to3-2.7
411toppm
7z
7z2john
7za
7zr
DPAPImk2john
FileCheck-16
FileCheck-17
GET
GenPat
HEAD
JxrDecApp
JxrEncApp
POST
Thunar
UnicodeNameMappingGenerator-16
UnicodeNameMappingGenerator-17

```

문자 범위에서 대시 문자는 특별하게 처리된다. ==그럼 어떻게 괄호 표현식에 실제 대시 문자를 포함할 수 있을까?== 그 문자를 표현식의 첫 문자로 만드는 것이다. 한번 생각해보자.

``` shell
┌──(kali㉿kali)-[~]
└─$ grep -h '[A-Z]' dirlist*.txt 
DPAPImk2john
FileCheck-16
FileCheck-17
GET
GenPat
HEAD
JxrDecApp
JxrEncApp
POST
Thunar
UnicodeNameMappingGenerator-16
UnicodeNameMappingGenerator-17
VBoxClient
X
X11
Xephyr

```

이것은 대문자를 가진 모든 파일명과 일치할 것이다. 반면 다음은

```shell
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~]
└─$ grep -h '[-AZ]' dirlist*.txt
2to3-2.7
DPAPImk2john
FileCheck-16
FileCheck-17
HEAD
JxrDecApp
JxrEncApp
UnicodeNameMappingGenerator-16
UnicodeNameMappingGenerator-17
aa-enabled
aa-exec
aa-features-abi
activate-global-python-argcomplete
aircrack-ng
airdecap-ng
airdecloak-ng
airolib-ng
airscan-discover
...
```

대시 또는 대문자 A나Z를 포함한 모든 파일명과 일치하게 된다.


### POSIX 문자 클래스

전통적인 문자 범위는 쉽게 이해되고 문자 집합을 빠르게 지정하기에 효율적인 방식이다. 하지만 불행히도 항상 동작하지는 않는다. 지금까지 우리가 grep을 사용하면서 어떤 문제와도 맞닥뜨리지 않았다면 다른 프로그램들을 사용하여 문제를 일으켜 볼 것이다.

우리는 4장에서 와일드카드가 어떻게 경로명 확장을 수행하는지 살펴보았다. 이와 비슷하게, 문자 범위는 정규 표현식에서 어느 정도 거의 비슷하게 사용될 수 있다. 하지만 문제가 있다.

```shell
┌──(kali㉿kali)-[~]
└─$ ls /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*
/usr/sbin/ModemManager  /usr/sbin/NetworkManager  /usr/sbin/SIPdump  /usr/sbin/VBoxControl  /usr/sbin/VBoxService
                                                                                                                      

```

(리눅스 배포판에 따라, 다른 파일 목록이나 빈 목록을 얻게 될 것이다. 이 예제는 우분투에 해당하는 것이다.) 이 명령어는 예상한대로, 대문자로 시작하는 이름을 가진 파일들만을 나열한다. 하지만 다음 명령은 완전히 다른 결과를 얻게 된다(일부 목록만을 나열).

>[!tip] 역자주
>사용자의 로케일 설정에 따라, 두 결과가 일치하는 경우도 있을 것이다.

``` shell
┌──(kali㉿kali)-[~]
└─$ ls /usr/sbin/[A-Z]*                       
/usr/sbin/ModemManager  /usr/sbin/NetworkManager  /usr/sbin/SIPdump  /usr/sbin/VBoxControl  /usr/sbin/VBoxService
                                                                                                              
```

왜 이런 걸까? 조금 긴 이야기이지만, 여기서는 짧게 말하겠다.

유닉스가 처음 개발된 시절로 돌아가면, 단지 ASCII 문자에 대해서만 알려져 있었다. 그리고 이 기능은 다음 사실을 반영한다. ASCII에서 첫 32자(숫자 0-31)는 제어 코드다(탭, 백스페이스, 캐리지 리턴 같은). 그 다음 32자(32-63)는 구두점 기호와 숫자 0부터 9까지를 포함한 출력 기능 문자들이다. 다음 32자(64-95)는 대문자와 소수의 구두점 기호를 포함한다. 마지막 31자(96-127)는 소문자와 아직도 남은 구두점 기호를 포함한다. 이 배열을 기준으로 시스템은 ASCII를 이용하여 다음과 같은 **조합 순서**를 사용한다.

`ABCDEFGHIJKLMNOPQSTUVWXYZabcdefghijklmnopqrstuvwxyz`

이것은 다음과 같이 올바른 사전 순서와는 다르다.

`aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ`

이것은 유닉스의 인기처럼 미국을 벗어나 확산되고, 따라서 ==미국과 영어에 없는 문자들의 지원이 필요해졌다. ASCII 테이블은 총 8비트를 사용하도록 확장됐다.== 더 많은 언어를 수용하기 위해 추가적으로 128-255번호와 문자를 도입했다. 그것은 특정 지역에 필요한 문자 집합을 선택하기 위해 조절 가능하도록 한 것이다. 다음 명령어로 시스템의 언어 설정을 볼 수 있다.

``` shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo $LANG
ko_KR.UTF-8

```

이 설정에 따라, POSIX 호환 응용프로그램들은 ASCII 순서보다 사전 조합 순서를 사용할 것이다. 이러한 이유로 사전순으로 해석될 때, 문자 범위 [A-Z]는 소문자 a를 제외한 알파벳 문자 모드를 포함한다.

이 문제를 부분적으로 해결하기 위해 POSIX 표준은 유용한 문자 범위를 제공하는 다수의 문자 클래스를 제공한다. 이 클래스들은 [표 19-2]에 설명되어 있다.


- [표 19-2] POSIX 문자 클래스

| 문자 클래스      | 설명                                                                       |
| ----------- | ------------------------------------------------------------------------ |
| `[:alnum:]` | ASCII 알파벳과 숫자; `[A-Za-z0-9]`                                             |
| `[:word:]`  | `[:alnum:]`와 동일, 밑줄 `(_)` 문자 추가됨                                         |
| `[:alpha:]` | ASCII 알파벳; [A-Za-z]와 동일                                                  |
| `[:blank:]` | 스페이스와 탭 문자                                                               |
| `[:cntrl:]` | ASCII 제어코드; ASCII 문자 0부터 31과 127번                                        |
| `[:digit:]` | 숫자 0부터 9                                                                 |
| `[:graph:]` | 출력 가능한 그래픽 문자; ASCII 문자 33부터 126까지                                       |
| `[:lower:]` | 소문자                                                                      |
| `[:punct:]` | ASCII 구두점 기호; `[-!"#$%^&*()+,.:;<=>?@[\\\]_{\|}~]` 와 동일                  |
| `[:print:]` | 출력 가능 문자; `[:graph:]`에 스페이스 문자 추가                                        |
| `[:space:]` | 공백 문자. ASCII의 스페이스 탭, 캐리지 리턴, 개행, 수직 탭, 폼 피드를 포함; `[\t \r \n \v \f]`와 동일 |
| `[:upper:]` | 대문자                                                                      |
| [:xdigit:]  | 16진수를 표현하는 ASCII 문자; `[0-9A-Fa-f]`와 동일                                   |

문자 클래스조차도 `[A-M]`과 같이 부분적인 범위를 지정하는 편리한 방법은 여전히 없다.

문자 클래스를 사용하여 디렉토리 나열을 반복할 수 있고 조금 더 향상된 결과를 볼 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ ls /usr/sbin/[[:upper:]]*
/usr/sbin/ModemManager  /usr/sbin/NetworkManager  /usr/sbin/SIPdump  /usr/sbin/VBoxControl  /usr/sbin/VBoxService
     
```

하지만 이것은 정규 표현식의 예제가 아니다. 다만 경로명 확장을 수행하는 쉘일 뿐이다. POSIX 문자 클래스가 두 경우에 모두 사용될 수 있기 때문에 확인해본 것이다.

>[!info] 일반적인 조합 순서 바꾸기
>사용자는 LANG 환경 변수 값을 변경하여 전통적인 (ASCII) 조합 순서를 시스템에서 이용할 수 있다. 이전 섹션에서 본 것처럼 LANG 변수는 사용자 환경에서 사용되는 언어 이름과 문자셋을 포함하고 있다. 이 값은 원래 리눅스 인스톨 시에 언어를 선택하여 결정되는 것이다.
>사용자 환경설정을 확인하려면 locale 명령어를 사용하면 된다.
>- [[locales]]
>전통적인 유닉스 방식으로 사용자 환경을 변경하려면 LANG 변수를 POSIX로 설정하라.
>```
>┌──(kali㉿kali)-[~]
└─$ export LANG=POSIX
>```
>이렇게 하면 시스템은 US English(조금 더 정확한 표현으로 ASCII)를 사용 언어로 지정하기 때문에 사용자가 실제로 원하는 언어인지에 대해서는 추가로 확인하길 바란다.
>
>이런 설정을 시스템에 영구 적용하려면 `.bashrc` 파일에 다음 내용을 추가하면 된다.
>`export LANG=POSIX`


---
# POSIX 기본 VS. 확장 정규 표현식


여러분은 이제 막 이해가 되는 듯 했는데, POSIX는 정규 표현식을 구현하는 방법을 두 가지로 구분한다는 사실을 알게 된다. **바로 기본 정규 표현식**(BRE)과 **확장 정규 표현식**(ERE)이다. 지금까지 다룬 내용은 POSIX 방식을 BRE를 구현하는 응용들이다.

그럼 BRE와 ERE의 차이점은 무엇일까? 이는 메타문자와 관계가 있다. BRE는 다음과 같은 메타문자들을 구분한다. `^ $ . [ ] *`

그 외 다른 문자들은 리터럴 문자로 인식된다. ERE에는 다음과 같은 메타문자들(그와 관련된 기능들까지)이 추가된다. `(){} ? + |`

하지만 (재미있게도), `() {}` 기호는 BRE에서는 백슬래시가 항상 함께 쓰여야만 메타 문자로 인식되지만, ERE에는 메타 문제 앞에 백슬래시 기호를 사용하게 된다면 리터럴 문자임을 의미하게 된다.

이제 우리가 다룰 부분은 ERE에 관란 것이며 다른 버전의 grep을 사용하게 될 것이다. 일반적으로, egrep이라는 프로그램이 수행될 것이다. 또한 GNU 버전의 grep도 -E 옵션을 사용하면 확장 정규 표현식을 지원한다.

>[!information] POSIX
>1980년대, 유닉스는 가장 유명한 상업용 운영체제로 자리 잡았다. 하지만 1988년까지 유닉스 세계는 혼돈 상태이기도 했다. 많은 컴퓨터 제조사들은 그 소유주인 AT&T에 유닉스 소스 코드를 허가 받았다. 그리고 자신의 시스템과 함께 다양한 버전의 운영체제를 제공했다. 이것으로 소프트웨어 호환성에 제한을 받기 시작했다. 다른 상업적인 벤더와 마찬가지로 제조사들이 소비자들과 시스템 비용 싸움에서 이기는 전략을 시도하고 있었다는 것이다. 유닉스 역사에서 암흑기라 할 수 있는 그 때를 **춘추전국시대**라 회자되고 있다.
>
>IEEE(전기 전자 기술자 협회)가 들어섰다. 1980년대 중바에, IEEE는 유닉스(또는 유닉스형의)시스템이 작동하는 방법에 대한 표준을 개발하기 시작했다. 이 표준은 IEEE 1003으로 알려져 있는데, **애플리케이션 프로그래밍 인터페이스**(APIs), 쉘 그리고 표준 유닉스형 시스템에서 볼 수 있는 유틸리티들을 규정한다. POSIX라는 이름은 **Portable Operating System Interface**의 약어(자연스러운 약어를 만들기 위해 X가 끝에 붙였다)로 리처드 스톨만(GNU의 리처드 스톨만)이 지었고 IEEE에 의해 사용되기 시작했다.



---

# 얼터네이션(Alternation)

확장 정규 표현식의 기능 중 첫 번째로 살펴볼 것은 **얼터네이션**(alternation)이라는 것이다. 이것은 표현식 집합 가운데에서 일치하는 것을 찾아주는 기능이다. 단지 괄호 표현식으로 여러 지정된 문자들 사이에서 일치하는 한 문자를 허용할 수 있다. 얼터네이션도 문자열 집핮이나 다른 정규 표현식에서 일치하는 것을 찾아준다.

이를 증명해보기 위해서 [[echo]]와 [[grep]] 명령어를 함께 사용할 것이다. 우선, 단순하고 진부한 문자열 비교를 시도해보자.

``` shell
┌──(kali㉿kali)-[~]
└─$ echo "AAA" | grep AAA  
AAA
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "BBB" | grep BBB
BBB

```

상당히 쉬운 예제다. 이 예제에서는 echo의 출력을 grep에 전달하여 그 결과를 볼 수 있다. 일치하는 것을 찾으면 출력되고, 그렇지 않은 경우엔 아무것도 출력되지 않는다.

이제 얼터네이션을 추가할 것이다 .**수직파이프 메타 문자**를 사용하여 표현한다.

``` shell
┌──(kali㉿kali)-[~]
└─$ echo "AAA" | grep -E "AAA|BBB"
AAA
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "BBB" | grep -E "AAA|BBB"
BBB
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "CCC" | grep -E "AAA|BBB"
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ 

```


'AAA|BBB'라는 정규 표현식을 볼 수 있는데 AAA나 BBB 문자열 중에서 일치하는 것을 찾으라는 뜻이다. 이것은 확장 기능이기 때문에 grep에 -E 옵션을 사용하였다(이 대신 egrep 명령어를 사용할 수도 있다). 그리고 정규 표현식을 따옴표로 감싸는 것은 수직 파이프 메타문자를 파이프 연산자와 헷갈리는 것을 방지하기 위해서다. 얼터네이션이 두 가지 선택으로만 제한되는 것은 아니다.

``` shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "AAA" | grep -E 'AAA|BBB|CCC'
AAA
        
```

얼터네이션과 다른 정규 표현식 요소들을 결합하여 사용하려면 () 기호로 얼터네이션을 구분해준다.

``` shell
┌──(kali㉿kali)-[~]
└─$ grep -Eh '^(bz|gz|zip)' dirlist*.txt
bzcat
bzcmp
bzdiff
bzegrep
bzexe
bzfgrep
bzgrep
bzip2
bzip2recover
bzless
bzmore
gzexe
gzip

```

이 표현식은 bz, gz, 또는 zip으로 시작하는 파일을 찾아줄 것이다. 만약 괄호를 사용하지 않았다면, 이 표현식의 뜻은 완전히 달라질 것이다. bz으로 시작하는 파일명이나, gz또는 zip 문자열을 포함하는 파일명을 찾으라는 의미를 갖게 된다.


``` shell
┌──(kali㉿kali)-[~]
└─$ grep -Eh '^bz|gz|zip' dirlist*.txt 
bunzip2
bzcat
bzcmp
bzdiff
bzegrep
bzexe
bzfgrep
bzgrep
bzip2
bzip2recover
bzless
bzmore
funzip
gpg-zip
gunzip

```

---
# 수량 한정자


확장 정규 표현식은 하나의 요소를 찾는 횟수를 지정하는 여러 방법을 지원한다.

#### ? -항목이 없거나 한 번만 나타나는 경우

이 한정자가 의미하는 것은 실제로는 "**그 앞의 요소는 선택적인 것이다**"라는 의미다. 예를 들어 전화번호의 유효성을 검사하고 싶다고 해보자. 그렇다면 다음과 같은 두 형식 중 하나와 일치하는 전화번호를 찾아야 할 것이다 : `(nnn)nnn-nnnn`또는 `nnn nnn-nnnn`

그렇다면 다음과 같이 정규 표현식을 만들어볼 수 있을 것이다.

`^\(?[0-9][0-9][0-9]\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$`

이 표현식에서는 괄호 기호 다음에 물음표를 이용하여 없거나 한 번만 일치하는 것을 찾도록 지정하고 있다. 괄호는 일반적으로 메타 문자(ERE에서)이기 때문에 백슬래시 기호를 선행하여 리터럴 문자로 해석되도록 한다.

다음의 예제로 실행해보자.

``` shell

┌──(kali㉿kali)-[~]
└─$ echo "(555) 123-4567" | grep -E '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$'
(555) 123-4567

┌──(kali㉿kali)-[~]
└─$ echo "AAA 123-4567" | grep -E '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$'
                                                                                                    

```

여기서 우리는 이 표현식으로 일치하는 두 형식의 전화번호를 찾았다. 그리고 숫자가 아닌 문자가 포함된 것은 찾지 않는 것을 알 수 있다.


#### `*`  항목이 없거나 여러 번 나타나는 경우
\
? 메타문자와 같이 `*` 기호는 임의의 사항을 입력할 대 사용된다. 하지만 ? 메타문자와는 달리, 요소가 여러 번 나타날 수 있다. 예를 들어, 한 문자열이 대문자로 시작하고 여러 대소문자와 공백을 포함하고 있으며 마지막은 마침표로 끝나는 문장을 원한다고 치자. 이러한 문장(아주 대충 만든 문장)을 찾기 위해서 우리는 다음과 같이 정규 표현식을 만들어볼 수 있다.

`[[:upper:]][[:upper:][:lower:]]*\`

이 표현식은 다음 세 가지로 구분할 수 있다. 1) `[:upper:]` 문자 클래스가 포함된 괄호식, 2) `[:upper:]`와 `[:lower]` 문자 클래스와 공백이 포함된 괄호식 . 3) 백슬래시와 함께 사용된 마침표, 두 번째 요소 다음에 `*` 메타문자가 따라오는데 이는 대문자로 시작하는 문자 다음에 여러 대소문자 및 공백이 있을 수도 있음을 의미한다. 결과는 다음과 같다.


``` shell
┌──(kali㉿kali)-[~]
└─$ echo "This works." | grep -E '^[[:upper:]][[:lower:][:upper:][:space:]]*\.$'  
This works.

┌──(kali㉿kali)-[~]
└─$ echo "This works." | grep -E '^[[:upper:]][[:lower:][:upper:] ]*\.$'     
This works.


┌──(kali㉿kali)-[~]
└─$ echo "this does not" | grep -E '^[[:upper:]][[:lower:][:upper:] ]*\.$'
                                                                               
```

이 표현식 앞의 두 테스트는 성공하지만 세 번째는 일치하지 않는다. 그 이유는 첫 글자가 대문자가 아니고 마침표로 끝나지 않기 때문이다.


### + 항목이 한 번 이상 나타나는 경우

`+` 메타 문자는 `*`와 거의 비슷하다. ==단, 찾으려는 요소와 일치하는 개체가 하나 이상 있어야 한다는 것을 제외하곤 말이다.== 단일 스페이스로 구분된 하나 이상의 알파벳으로 구성된 그룹을 찾는 정규 표현식 예제를 살펴보자.


`([[:alpha:]]+ ?)+$`

다음과 같이 입력해보자.

``` shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "This that" | grep -E '^([[:alpha:]]+ ?)+$'                      
This that
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "a b c" | grep -E '^([[:alpha:]]+ ?)+$'    
a b c
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "a b 9" | grep -E '^([[:alpha:]]+ ?)+$'
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "abc d" | grep -E '^([[:alpha:]]+ ?)+$'
abc d
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ echo "abc  d" | grep -E '^([[:alpha:]]+ ?)+$'

```

결과를 보면 "a b 9 "는 일치하지 않는데 그 이유는 알파벳이 아닌 다른 문자가 포함되어 있기 때문이다. ==마지막 줄의 "abc d " 역시 c와 d 사이에 하나 이상의 스페이스가 포함되어 있기 때문이다.==



### {} 항목이 지정된 횟수만큼 나타나는 경우

`{, }` 메타 문자는 검색 횟수의 최소와 최대값을 지정할 때 사용된다. [표 19-3]에서 표현할 수 있는 네 가지 방법을 소개한다.


- [표 19-3] 일치 횟수 지정

| 명시자     | 의미                               |
| ------- | -------------------------------- |
| `{n}`   | 정확히 n번만 일치하는 선행 요소 검색            |
| `{n,m}` | 최소 n번, 하지만 m번 미만으로 일치하는 선행 요소 검색 |
| `{n,}`  | n번 이상 일치하는 선행 요소 검색              |
| `{,m}`  | m번 미만 일치하는 선행 요소 검색              |

전화번호를 검색했던 이전 예제를 다시 보면, ==이 예제에서 반복 횟수를 지정함으로써 조금 더 간단하게 표현할 수 있을 것이다.==

`^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$`

에서 

`^\(?[0-9]{3}\)? [0-9]{3}-[0-9]$`

로 변경한다. 예제를 실행해보자.


``` shell
┌──(kali㉿kali)-[~]
└─$ echo "(555) 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
(555) 123-4567
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~]
└─$ echo "555 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$' 
555 123-4567
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~]
└─$ echo "5555 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~]
└─$ 

```


살펴본 바와 같이 수정된 표현식은 괄호가 있건 없건 유효한 전화번호를 검색할 수 있다. 또한 형식과 맞지 않는 전화번호는 제외되었다.


---
# 정규 표현식 활용


우리가 이미 알고 있는 명령어 몇 가지를 다시 살펴보고 정규 표현식과 응용해서 사용할 수 있는지 알아보자.


### grep 명령어로 유효한 전화번호 찾기


앞의 예제에서 하나의 전화번호를 검사해서 주어진 형식에 맞는지 확인하였다. 좀 더 현실적으로 여러 개의 전화번호 목록을 확인하는 작업이 필요할 것이다. 먼저 전화번호 목록을 만들어보자. 이를 위해 커맨드라인에 마법 같은 주문을 걸어보자. 그것이 마법인 이유는 여기에 사용될 명령들이 아직 우리가 다루지 않은 것들이 대부분이기 때문이다. 하지만 걱정하지 않아도 된다. 금방 배울 것이다. 주문을 걸어보자.

``` shell
┌──(kali㉿kali)-[~]
└─$ for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-4{RANDOM:0:4}" >> phonelist.txt; done

```

이 명령어로 10개의 전화번호를 가진 phonelist.txt 라는 이름의 파일을 생성했다. 명령이 반복될 때마다 또 다른 10개의 번호가 파일에 추가될 것이다. 또한 커맨드라인 시작 부분의 숫자 10을 다른 값으로 변경하여 더 많거나 또는 더 적게 전화번호를 추가할 수 있다. 파일 내용을 확인해보면 약간의 문제가 있음을 알 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ cat phonelist.txt                                                                             
(313) 135-2737
(276) 316-2721
(255) 316-2302
(155) 296-3231
(290) 224-4727
(772) 255-2481
(307) 144-1799
(288) 278-2357
(691) 179-1137
(271) 173-1023

```

그것이 유효한지 입증하기 위해 grep을 사용했기 때문에 일부 숫자 형식이 이상하다. 이는 우리의 목적에 완전히 부합하다.

유효성 검사 방법 중 유용한 것은 잘못된 숫자를 찾아서 표시하는 것이다.

``` shell
┌──(kali㉿kali)-[~]
└─$ grep -Ev '^\( [0-9]{3} \) [0-9]{3}-[0-9]{4}$' phonelist.txt
(313) 135-2737
(276) 316-2721
(255) 316-2302
(155) 296-3231
(290) 224-4727
(772) 255-2481
(307) 144-1799
(288) 278-2357
(691) 179-1137
(271) 173-1023

```

`-v` 옵션을 사용하면 명령의 원 결과와는 정반대인 결과를 보여주기 때문에 우리 표현식과 일치하지 않는 결과를 출력할 수 있다. 그 번호의 어느 쪽 끝에도 여분의 문자가 없어야 함을 보장하기 위해 이 표현식 자체는 각 끝에 앵커 메타 문자를 포함한다. 이 표현식은 또한 유효한 숫자에 대하여 괄호를 사용하고 있는데, 이 부분은 앞서 보았던 전화번호 예제와는 다른 부분이다.


### find 잘못된 파일명 찾기

find 명령어는 정규 표현식을 기초로 하여 테스트하는 데 사용될 수 있다. grep과 비교하여, find 명령어에서 정규 표현식을 사용할 때 중요하게 짚고 넘어가야 하는 것이 있다. grep은 표현식과 일치한는 문자열이 포함된 결과를 출력하지만 find는 정규 표현식과 정확히 일치하는 경로명이 필요하다. 다음 예제에서는 정규 표현식을 find과 함께 사용하여 다음 문자 집합에 포함되지 않는 문자를 가진 모든 경로명을 찾을 것이다.


`[-_./0-9a-zA-Z]`

이런 검색으로 숨겨진 공백 문자나 잠재적으로 문제가 되는 다른 문자가 포함된 경로명을 찾아낼 수 있다.

``` shell
┌──(kali㉿kali)-[~]
└─$ find . -regex '*[^-_./0-9a-zA-Z].*'               
                                        
```

경로명 전체와 정확하게 일치하는 조건을 명시하기 위해서 `.*`을 표현식 끝에 모두 사용하여 아무 문자가 존재하지 않거나 어떤 문자가 한 번 이상 존재하는 개체와 일치하는 것을 찾도록 하였다. 표현식 중간 부분을 보면 허용되는 경로명 문자들을 포함하고 있는 부정 괄호식을 사용하였다.


### locate 로 파일 검색하기

locate 프로그램은 기본 정규 표현식(--regexp 옵션) 및 확장 정규 표현식(--regex 옵션) 모두를 지원한다. 이 명령어로 이전에 dirlist 파일들에 수행했던 동일한 작업들을 실행할 수 있다.


``` shell
┌──(kali㉿kali)-[~]
└─$ locate --regex 'bin/(bz|gz|zip)'
/usr/bin/bzcat
/usr/bin/bzcmp
/usr/bin/bzdiff
/usr/bin/bzegrep
/usr/bin/bzexe
/usr/bin/bzfgrep
/usr/bin/bzgrep
/usr/bin/bzip2
/usr/bin/bzip2recover
/usr/bin/bzless
/usr/bin/bzmore
/usr/bin/gzexe
/usr/bin/gzip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipdetails
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
/usr/lib/klibc/bin/gzip
/usr/sbin/zip2john

```

얼터네이션을 활용하여 bin/bz, bin/gz, /bin/zip이 포함된 경로명을 검색할 수 있다.


### less와 vim으로 텍스트 검색하기

less와 vim 프로그램은 텍스트를 검색하는 방법이 똑같다. / 키를 입력하고 정규 표현식을 입력하면 검색이 실행된다. phonelist.txt 파일을 보기 위해 less를 사용해보자.

``` shell

┌──(kali㉿kali)-[~]
└─$ less phonelist.txt              
                         
```

그 다음 유효한 전화번호를 찾기 위해 표현식을 입력해보자.


```shell


(313) 135-2737
(276) 316-2721
(255) 316-2302
(155) 296-3231
(290) 224-4727
(772) 255-2481
(307) 144-1799
(288) 278-2357
(691) 179-1137
(271) 173-1023            
                         
```


less는 일치하는 문자열을 강조해서 표시해주기 때문에 유효하지 않은 결과는 알아보기 쉬울 것이다.

``` shell
(313) 135-2737
(276) 316-2721
(255) 316-2302
(155) 296-3231
(290) 224-4727
(772) 255-2481
(307) 144-1799
(288) 278-2357
(691) 179-1137
(271) 173-1023
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~(/^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$를 입력하면 이에 해당하는 문자열은 전부 선택되어진다.)
(END)

```

반면, vim 프로그램은 기본 정규 표현식을 지원하기 때문에 표현식은 다음과 같이 변경될 것이다.

`/^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$`

표현식을 거의 비슷하다. 하지만 확장 표현식에서 메타문자로 여겨지는 문자들이 기본 표현식에서는 리터럴 문자로 받아들인다. 그것들은 백슬래시로 확장되어야만 메타문자로 인식된다. 시스템의 vim 환경설정에 따라 일치하는 값은 하이라이트 될 수 있다. 그렇지 않다면 명령 모드와 명령어 `:hlsearch`를 사용해보길 바란다. 이 명령어는 검색 결과를 강조해준다.


>[!tip] 저자주
>사용하는 배포판에 따라, vim 프로그램에서 텍스트 강조 기능이 지원여부가 달라진다. 우분투의 경우 기본적으로 가장 기본기능만 있는 vim 프로그램이 설치되어 있기 때문에 이런 경우는 패키지 관리자를 사용하여 확장 버전의 vim을 설치해야 한다.

---
# 마무리 노트

이번 장에서 다룬 것은 정규 표현식의 빙산의 일각일 뿐이다. 우리는 정규 표현식의 추가 사용법을 찾기 위해 정규 표현식을 사용하는 것 또한 가능하다. 즉 이를 통해 man 페이지를 검색할 수 있다.

``` shell
                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ cd /usr/share/man/man1
                                                                                                                   
┌──(kali㉿kali)-[/usr/share/man/man1]
└─$ zgrep -El 'regex|regular expression' *.gz
FileCheck-16.1.gz
FileCheck-17.1.gz
apropos.1.gz
apt-file.1.gz
awk.1.gz
bash.1.gz
binwalk.1.gz
bulk_extractor.1.gz
busybox.1.gz
bzegrep.1.gz
bzfgrep.1.gz
...
```

zgrep 프로그램은 grep의 프론트엔드로 압축파일을 읽어올 수 있다. 이 예제는 압축된 [[man]] 페이지 섹션 1 파일을 man 페이지가 있는 위치를 검색하고 있다. 이 명령의 결과는 regex 문자열 또는 regular expression이 포함된 파일들이다. 결과를 통해, 정규 표현식이 수많은 프로그램에서 사용되고 있는 것을 알 수 있다.

우리가 아직 다루지 않는 기본 정규 표현식 기능이 하나가 있다. 후방 참조(back reference)라는 것 인데, 바로 다음 장에서 살펴볼 것이다.