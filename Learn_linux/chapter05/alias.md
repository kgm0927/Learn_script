

---

[[set]]이나 [[printenv]] 명령어가 표시하지 않는 하나의 환경 요소는 바로 별칭이다. 이를 보려면 alias 명령어를 인자 없이 입력하면 된다.


``` shell

┌──(kali㉿kali)-[~]

└─$ alias

diff='diff --color=auto'

egrep='egrep --color=auto'

fgrep='fgrep --color=auto'

grep='grep --color=auto'

history='history 0'

ip='ip --color=auto'

l='ls -CF'

la='ls -A'

ll='ls -l'

ls='ls --color=auto'

which-command=whence
```


- 흥미로운 몇 가지 변수들

환경에는 수많은 변수가 있는데 사용자의 환경이 여기서 소개하는 것들과는 다를 수는 있어도, 표11-1에 있는 변수들과는 어느 정도 유사할 것이다.


[표11-1] 환경 변수

| 변수      | 내용                                                                                            |
| ------- | --------------------------------------------------------------------------------------------- |
| DISPLAY | 그래픽 환경 사용자인 경우 디스플레이명. 보통은 :0인데 X 서버에 의해 생성된 가장 첫 번째 디스플레이라는 것이다.                             |
| EDITOR  | 텍스트 편집에 기본적으로 사용되는 프로그램 이름                                                                    |
| SHELL   | 홈 디렉터리 경로명.                                                                                   |
| LANG    | 사용자 언어의 문자셋과 정렬 방식 정의하기.                                                                      |
| OLD_PWD | 이전 작업 디렉토리                                                                                    |
| PAGER   | 페이지 출력에 사용되는 프로그램 이름. 주로 /usr/bin/less가 설정되어 있다.                                              |
| PATH    | 실행 프로그램명을 입력할 때, 그 이름을 찾는 디렉토리 목록(콜론으로 구분)                                                    |
| PS1     | 프로프트 문자열 1. 쉘 프롬프트 내용을 정의한다. 추후에 살펴보겠지만 광범위한 설정이 가능하다.                                        |
| PWD     | 현재 작업 디렉토리                                                                                    |
| TERM    | 사용자 터미널 타입 이름. 유닉스형 시스템에서는 터미널 프로토콜을 지원하는데 이 변수로는 사용자의 터미널 에물레이터와 함께 사용할 수 있는 프로토콜을 정의한다.     |
| TZ      | 사용자의 시간대를 설정한다. 대부분의 유닉스형 시스템은 국제 표준시(UTC)에 따라 시간을 유지하지만 이 변수로 시간을 차감하여 사용자의 지역 시간을 표시할 수 있다. |
| USER    | 사용자 이름.                                                                                       |
|         |                                                                                               |

배포판마다 약간씩 다르다.



---
# 환경은 어떻게 생성할까?

시스템에 로그인하면 bash 프로그램이 시작되면 **시작 파일**(startup files)이라고 하는 일련의 환경 설정 스크립트를 읽는다. 이 시작 파일은 모든 사용자에게 공유되는 기본적인 환경 설정 값을 규정한다. 이어서 개인 사용자의 환경을 정의하는 홈 디렉토리 내의 시작 파일이 구성된다. 정확한 순서는 실행된 쉘 세션에 따라 달라지게 된다.


- 로그인 여부에 따른 쉘 환경

두 종류의 쉘 세션이 있다. **로그인 쉘 세션**, **비로그인 쉘 세션**

**로그인 쉘 세션**: 사용자 이름과 비밀번호를 입력하도록 되어 있는데 예를 들어 가상 콘솔 세선이 시작할 때다.

**비로그인 세션**: 일반적으로 GUI 환경에서 터미널 세션을 실행할 때 나타난다.


[표 11-2] 로그인 쉘 세션용 시작 파일

| 파일                    | 내용                                                                                                 |
| --------------------- | -------------------------------------------------------------------------------------------------- |
| `/etc/profile`        | 모든 사용자에게 적용되는 일반 환경설정.                                                                             |
| *`pwd/.bash_profile`* | 개인 사용자 시작 파일. 일반 환경설정을 확장하거나 무시할 수 있다.                                                             |
| *`pwd/.bash_login`*   | pwd/.bash_profile이 없으면 bash는 이 스크립트를 읽게 된다.                                                        |
| pwd/.profile          | pwd/.bash_profile이나 pwd/.bash_login 모두 없으면 bash는 이 파일을 읽는다. 우분투와 같은 데비안 배포판에서는 이 파일이 기본으로 설정되어 있다. |



[표 11-3] 비로그인 쉘 세션용 시작 파일


| 파일               | 내용                                     |
| ---------------- | -------------------------------------- |
| /etc/bash.bashrc | 모든 사용자에게 적용되는 일반 환경설정.                 |
| pwd/.bashrc      | 개인 사용자 시작 파일. 일반 환경설정을 확장하거나 무시할 수 있다. |


비로그인 쉘은 이 시작 파일을 읽는 것뿐만 아니라 로그인 쉘 같은 상위 프로세스로부터 환경 값을 물려 받는다.

상단에 나열된 대부분의 시작파일은 마침표(숨김 파일)로 시작하기 때문에 **ls**에 **–a** 옵션을 사용해야 할 것이다.

**~/.bashrc** 파일은 일반 사용자 관점에서 아마도 가장 중요한 파일일 것이다. 왜냐하면 항상 참조되는 파일이기 때문이다. 비로그인 쉘은 기본적으로 이 파일을 읽고, 로그인 쉘용 시작파일 대부분은 **~/.bashrc** 파일을 기본적으로 참조하도록 만들어지기 때문이다.


- 시작 파일에는 어떤 것이 있을까?

전형적인 .bashrc 파일을 들여다 보겠다(현재 쓰고 있는 칼리 리눅스에는 bash_profile이 없다). 다음과 비슷할 것이다.


``` shell
┌──(kali㉿kali)-[~]

└─$ cat .bashrc

# ~/.bashrc: executed by bash(1) for non-login shells.

# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)

# for examples

# If not running interactively, don't do anything

case $- in

*i*) ;;

*) return;;

esac

... 그 외 ...
```


`#` 기호로 시작하는 줄은 주석을 달아놓은 것고 쉘이 참조하는 부분이 아닌, 사용자를 위한 정보다. 재미있는 건 다음과 같은 부분이다.


이는 **‘if 합성 명령어’** 라고 하는데 4부에서 쉘 스크립트를 공부할 때 아주 자세하게 알게 될 것이다.


커맨드라인에 명령어를 입력하면 쉘이 어떻게 찾아내는지 궁금해 본 적이 있는가? 예를 들어, ls 명령어를 입력했을 때, 쉘은 /bin/ls(ls 명령어의 전체 경로명) 를 찾기 위해서 쉘이 컴퓨터 전체를 검색하는 것이 아니라 PATH 변수에 있는 디렉토리를 대상으로만 검색하면 된다.

**PATH**는 $HOME/bin 디렉토리를 목록 끝에 추가하도록 설정되어 있다. 다음은 매개 변수 확장 예제로 7장에서 살펴본 것이다.

이 설정이 어떻게 작동되는지 보여주기 위해 다음과 같이 하는 게 좋다.


``` shell
┌──(kali㉿kali)-[~]

└─$ foo="this is some"

┌──(kali㉿kali)-[~]

└─$ echo $foo

this is some

┌──(kali㉿kali)-[~]

└─$ foo=$foo"text."

┌──(kali㉿kali)-[~]

└─$ echo $foo

this is sometext.
```


이 방법을 활용해서 변수 내용 끝에 텍스트를 삽입할 수 있다.

PATH 내용 끝에 $HOME/bin 문자열을 추가함으로써 $HOME/bin 디렉토리는 명령어가 입력될 때 검색되는 디렉토리 목록에 덧붙여진다. 즉 사용자만의 프로그램을 저장하기 위해 홈 디렉토리 내에 디렉토리를 생성하고 싶다면, 쉘은 그것을 수용할 준비가 되어 있다. 우리가 할 일은 그것을 bin이라고 부르는 것이고, 이제 작업할 준비가 다 됐다.

저자주: 많은 배포판에서는 이러한 PATH 설정을 기본적으로 제공하고 있다. 우분투와 같이 일부 데비안 베포판은 로그인 시에 ~/bin 디렉토리 존재 여부를 확인하고 존재한다면 자동으로 PATH 변수에 이 디렉토리를 추가한다.

마지막으로 할 일이다.

[[export]]