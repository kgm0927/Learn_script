

---
# 시그널


명령어 ‘kill’은 프로세스를 종료하기 위해 사용된다. 이는 비정상적으로 동작하거나 그렇지 않으면 종료를 거부하는 프로그램의 실행이 끝나게 한다.


``` shell
┌──(kali㉿kali)-[~]

└─$ xlogo &

[2] 6983

┌──(kali㉿kali)-[~]

└─$ kill 6983

[2] + terminated xlogo
```


먼저 xlogo를 백그라운드에서 실행한다. 수레에는 백그라운 프로세스의 PID와 jobspec이 출력된다. 그 다음, 종료할 프로세스 PID와 함께 kill 명령어를 사용한다. PID 대신에 jobspec(예를 들면, %1)을 사용하여 프로세스를 명시할 수 있다.

아주 간단하지만, 중요한 것은, 정확히 kill 명령어는 프로세스를 종료(‘kill’)하지 않는다. 오히려 프로세스에 시그널을 보낸다는 표현이 옳다. 시그널은 운영체제가 프로그램들과 통신하기 위한 여러 가지 방법 중 하나다. 이미 ctrl-C와 ctrl-Z의 사용에서 시그널을 본적이 있다.

터미널이 이 키 입력들 중 하나를 받을 때 포그라운드에 있는 프로세스에 시그널을 보낸다. ctrl-C의 경우에는 **INT**(인터럽트) 시그널을 보내고 ctrl-Z는 **TSTP**(터미널 정지) 시그널을 보낸다. 프로그램들은 결국 시그널을 귀 기울이고(“listen”) 있다가 받은 시그널에 따라 행동하게 된다.

프로그램들이 시그널을 들을 수 있고 그에 따라 행동한다는 사실은 종료 시그널을 받았을 때 진행 중인 작업을 저장하는 것과 같은 동작이 가능하다는 것을 나타낸다.


- kill로 시그널 보내기

kill 명령어의 일반적인 문법은 다음과 같다.

`kill [-signal] PID ...`


커맨드라인에 지정된 시그널이 없다면, 기본적으로 '**TREM**'(종료) 시그널을 보낸다. '**kill**' 명령어는 아래의 표에 있는 시그널을 주로 사용한다.


[표 10-4] 주요 시그널

|   |   |   |
|---|---|---|
|번호|이름|의미|
|1|HUP|Hang up. 이는 전화선과 모뎀으로 원격 컴퓨터에 연결하는 터미널을 사용하던 흔적 옛날 흔적이다. 이 시그널은 제어 터미널과 “연결이 끊어진” 프로그램을 프로그램을 가리키는 데 사용된다. 이 시그널은 터미널 세션 종료에 의해 나타난다. 터미널에서 실행 중인 포그라운드 프로그램은 이 시그널을 받으면 종료가 된다.<br><br>또 재초기화를 위해 많은 데몬 프로그램에서 사용된다. 이는 데몬이 이 시그널을 받으면 재시작하고 환경설정 파일을 다시 읽어 들이게 된다는 것을 의미한다.<br><br>Apache 웹 서버가 HUP 시그널을 이 방식으로 사용하는 데몬의 한 예다.|
|2|INT|Interrupt. 터미널에서 ctrl-C 키를 보낸 것과 동일한 기능을 한다. 프로그램을 항상 종료시킨다.|
|9|KILL|Kill. dl 시그널은 조금 특별한데, 프로그램은 자신에게 보내진 시그널들을 모두 무시하거나 다른 방식으로 조작하는 것을 선택할지 모른다. KILL 시그널은 실제로 해당 프로그램에 보내지지 않는다. 오히려 커널이 즉시 프로세스를 종료한다.<br><br>이런 식으로 프로세스가 강제 종료되면 스스로 정리하거나 진행 중인 작업을 저장할 기회가 없다. 이런 이유로 KILL 시그널은 다른 종료 시그널이 실패한 경우에 마지막 수단으로 사용되어야 한다.|
|15|TERM|Terminate. 이것은 kill 명령어가 보내는 기본 신호다. 이 신호를 보냈을 때 만약 프로그램이 여전히 시그널을 받을 수 있을 정도로 “살아있다면” 프로그램은 종료될 것이다.|
|18|CONT|Continue. STOP 시그널로 정지된 프로세스를 복원한다.|
|19|STOP|Stop. 이 시그널은 프로세스를 종료 없이 일시 정지시킨다.|


이제 kill 명령어를 사용해본다.

``` shell
┌──(kali㉿kali)-[~]

└─$ xlogo &

[1] 38527

┌──(kali㉿kali)-[~]

└─$ kill -1 38527

[1] + hangup xlogo
```


이 예제에서는 xlogo 프로그램을 백그라운드로 시작하고 kill 명령어를 통하여 그 프로그램에 HUP 시그널을 보냈다. xlogo 프로그램은 종료되고, 쉘은 hangup 시그널을 받은 백그라운드 프로세스를 보여준다. 그 메시지를 보려면 두 세 번 정도 enter 키를 눌러야 할 지도 모른다. 시그널 이름이든 번호로든 명시해야 한다는 것을 유념하라.


SIG로 시작하는 시그널 이름을 사용할 수도 있다.


``` shell
[1] + hangup xlogo

┌──(kali㉿kali)-[~]

└─$ xlogo &

[1] 40170

┌──(kali㉿kali)-[~]

└─$ kill -INT 40170

[1] + interrupt xlogo

┌──(kali㉿kali)-[~]

└─$ xlogo &

[1] 40499

┌──(kali㉿kali)-[~]

└─$ kill -SIGINT 40499

[1] + interrupt xlogo
```

한 가지 알아야 할 점은 PID 위치에 jobspec을 사용할 수 있다는 것이다.

프로세스들은 파일처럼 소유자를 가지고 있다. kill 명령어로 프로세스에 시그널을 보내려면 반드시 그 프로세스의 소유자거나 슈퍼유저여야 한다.

추가적으로 표 10-4에서 본 **kill** 명령어와 자주 사용하는 시그널 목록 외에 시스템에서 자주 사용하는 시그널들이 있다. 밑의 표에 그 다른 시그널들을 나열했다.


[표 10-5] 그 외 주요 시그널

| 번호  | 이름    | 의미                                                                                                                                |
| --- | ----- | --------------------------------------------------------------------------------------------------------------------------------- |
| 3   | QUIT  | Quit.<br><br>(*역자주: 사용자가 종료 키(ctrl+\)를 입력하면 커널이 프로세스에 SIGQUIT 시그널을 보낸다.)                                                          |
| 11  | SEGV  | Segmentation violation.<br><br>이 시그널은 프로그램이 잘못된 메모리 사용이 이뤄질 때 보내진다. 즉 허용하지 않은 영역에 쓰기를 시도했다는 것이다.                                  |
| 20  | TSTP  | Terminal Stop.<br><br>이 시그널은 ctrl-Z를 눌렀을 때 터미널에 의해 보내진다. STOP 시그널과 달리 TSTP 시그널은 프로그램에 의해 받게 된다. 하지만 프로그램은 이를 무시하도록 지정되어 있을 수도 있다. |
| 28  | WINCH | Window change.<br><br>이 시그널은 윈도우 크기가 변경된 경우에 시스템에 의해 보내진다. top과 less와 같은 프로그램들은 이 시그널을 받으면 새로운 윈도우 크기에 맞게 다시 그려질 것이다.             |


전체 시그널 목록을 볼 수 있는 명령이 있다.

``` shell
┌──(kali㉿kali)-[~]

└─$ kill -l

HUP INT QUIT ILL TRAP IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS
```